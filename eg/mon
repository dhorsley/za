#!/usr/bin/za

#
# Test script for za.
# If this is working, the language probably is.
#
# This program displays a few pieces of key system 
# resource information on a single summary view.
#

#
# FUNCTIONS
#

count=0

logging on "/tmp/dh"

define clear(lstart,lend,column)
    for f=lstart to lend
        clear_line(f,column)
    endfor
end

define bar(row,col,hsize,pc,colour)
    part_3q="▊"
    part_2q="▌"
    part_1q="▎"
    us = hsize / 100f   # 1% width of total
    d  = pc*us          # width of input percent
    r  = d-d.int        # remainder
    for e=0 to hsize-1
        at row,col+e
        c=" "
        on e<d.int do c="█"
        if e>=d.int and e<int(d+1)
            on r>=0.25*us do c=part_1q
            on r>=0.50*us do c=part_2q
            on r>=0.75*us do c=part_3q
        endif
        print "[#{colour}]{c}[#-]"
    endfor
end

define interface_ip(in)
    addrline =< ip addr show dev {in}
    ipaddr=replace(filter(addrline,"inet.*/"),"inet ","")
    ipaddr=replace(ipaddr,"/","")
    return ipaddr
end

define negreg(inp,matcher)
    out=""
    foreach l in inp
        if match(l,matcher); continue; endif
        out=out+l+"\n"
    endfor
    return out
end

test "fn_ip" group "mon" assert fail
    iip=interface_ip("lo:")
    assert has_start(iip,"127.0.0.")
endtest

define shorten(s,l)
    on len(s)>=l do s=s[:l-2]+(?? utf8supported() "…","~")
    return s
end

define showEnv()
    pane select "envs"
    print linecolour; pane redraw
    clear(2,11,1)
    cursoroff()

    at 2,3, "[#-]Hostname             : [#6]{=hostname()}[#-]"
    at 3,3, "Bash Version         : [#6]{=bash_version()}[#-]"
    at 4,3, "User                 : [#6]{=user()}[#-]"
    at 5,3, "OS                   : [#6]{=os()}[#-]"
    at 6,3, "Locale               : [#6]{=lang()}[#-]"
    at 7,3, "Distribution         : [#6]{=release_name()}[#-]"
    at 8,3, "Distribution Version : [#6]{=release_version()}[#-]"
end


define showFiles()

    cursoroff()
    if !winterm()

        open_fd=""
        open_inode=""

        on is_file("/proc/sys/fs/file-nr")  do open_fd    = $in "/proc/sys/fs/file-nr"
        on is_file("/proc/sys/fs/inode-nr") do open_inode = $in "/proc/sys/fs/inode-nr"

        on open_fd=="" || open_inode=="" do return

        pane select "files"
        print linecolour; pane redraw

        clear(1,4,1)

        ofd=open_fd.field(1,"\t")
        mfd=open_fd.tr("d","\n").tr("s","\t ").field(3,"\t ").float
        at 2,2, "[#-]Open Descr. : [#6]{ofd}[#-]"
        at 3,2, "Max         : [#6]"
        if mfd>1e8
            print "No Limit[#-]"
        else
            print format("%.7g",mfd),"[#-]"
        endif
        fin=open_inode.field(2," \t\n")
        tin=open_inode.field(1," \t").float
        at 4,2, "Free Inodes : [#6]{fin}[#-]"
        at 5,2, "Total       : [#6]",format("%.7g",tin),"[#-]"

    endif

end


define showMem()

    pane select "mem"
    print linecolour; pane redraw

    cursoroff()

    if !access
        at 2,1,"[#1]Slab information requires root access.[#-]"
        return
    endif

    # gather
   
    slab_file="" 
    on is_file("/proc/slabinfo") do slab_file=$in "/proc/slabinfo"

    slabs=""
    if slab_file.count>1
        foreach l in slab_file.lines("2:")
            name=l.field(1," \t")
            s_sz=l.field(3," \t")
            s_cn=l.field(4," \t")
            on s_sz==0 or s_cn==0 do continue
            slabs+="%s %3v\n".format(name,(s_sz.float*s_cn.float)/1024/1024)
        endfor
        slabs=slabs.fieldsort(2,"n",true) 
    endif

    foreach f in ["total","free","avail","cached","active","swap_free","swap_total"]
        mem[f]=0
    endfor

    if is_file("/proc/meminfo")
        foreach line in $in "/proc/meminfo"
            fields(line)
            if F[2]!=""
                when F[1]
                    is "MemTotal:";     mem_total=F[2]
                    is "MemFree:";      mem_free=F[2]
                    is "MemAvailable:"; mem_avail=F[2]
                    is "Cached:";       mem_cached=F[2]
                    is "Active:";       mem_active=F[2]
                    is "SwapFree:";     mem_swap_free=F[2]
                    is "SwapTotal:";    mem_swap_total=F[2]
                endwhen
            endif
        endfor
    endif

    # display mem

    clear(2,9,1)

    at 2,1, "[#4]Total  : "; bar(2,10,16,mem_total.float*100,1)
    print " [#6]{=hobbitsize(1024*mem_total.float)}B[#-]"

    at 3,1, "[#4]Free   : "; bar(3,10,16,(mem_free.int/mem_total.float)*100,4)
    print " [#6]{=hobbitsize(1024*mem_free.float)}B[#-]"

    at 4,1, "[#4]Avail  : "; bar(4,10,16,(mem_avail.int/mem_total.float)*100,4)
    print " [#6]{=hobbitsize(1024*mem_avail.float)}B[#-]"

    at 5,1, "[#4]Cached : "; bar(5,10,16,(mem_cached.int/mem_total.float)*100,3)
    print " [#6]{=hobbitsize(1024*mem_cached.float)}B[#-]"

    at 6,1, "[#4]Active : "; bar(6,10,16,(mem_active.int/mem_total.float)*100,3)
    print " [#6]{=hobbitsize(1024*mem_active.float)}B[#-]"

    at 7,1, "[#4]Fr Swap: "; bar(7,10,16,(mem_swap_free.int/mem_swap_total.float)*100,5)
    print " [#6]{=hobbitsize(1024*mem_swap_free.float)}B[#-]"

    al=get_mem().alloc.int
    ts=get_mem().system.int
    at 8,1, "[#4]Mon Use:"; bar(8,10,16,(al.float/mem_avail.int)*100,2)
    print " [#6]{=hobbitsize(al*1024*1024)}B [#-]"

    # display slab info

    cs=8
    on count(slabs)<8 do cs=count(slabs)

    comwidth=10
    at 10,1, format("[#b2][#7][#bold]%20s  %-{comwidth}s[##][#-]","slab allocatee","MB size")
    # would normally do with fields(). showing alternative below:
    if count(slabs)>0
        for p = 0 to cs-1
            l=lines(slabs,"{p}:{p}")
            sa=strpos(l," ",0)
            c1=substr(l,0,sa)
            c2=substr(l,sa+1,len(l)-sa-1)
            at 11+p,1, format("%20s  [#6]%-"+comwidth.string+"d[#-]",c1,int(c2))
        endfor
    endif
end


define showProcs(ct,uptime)

    pane select "procs"
    print linecolour; pane redraw

    cursoroff()

    # get filenames
    procs =< ls -1 /proc/*/stat
    procs = line_filter(procs,"/[0-9]+/")

    foreach p in procs
        on !is_file(p) do break
        ps = $in p

        comm=tr(filter(ps,`\(.*?\)`),"d","()")
        ps=replace(ps,`\(.*?\)`,`"comm"`)

        # split up
        fields(ps)
        pid=int(F[1])

        state=F[3]; ppid=F[4]
        utime=float(F[14]); stime=float(F[15]); cutime=float(F[16]); cstime=float(F[17])
        priority=F[18]; nice=F[19]; threads=F[20]; procstarttime=float(F[22])

        on kind(procstarttime)!="float" || kind(utime)!="float" || kind(stime)!="float" do continue
        on kind(cstime)!="float" || kind(cutime)!="float" do continue

        on procstarttime==0 do continue

        # if not this process' pid (putime: seconds of process time) // putime==0 when proc just started.

        if pid!=pid()
            putime=float(uptime-(procstarttime/ct))
            on putime==0 do continue

            proc_list[pid]=[ state, ppid, 100*float(utime/ct/putime), 100*float(stime/ct/putime), 
                            100*float(cutime/ct/putime), 100*float(cstime/ct/putime), 
                            threads, procstarttime, gsub(comm," ","_") 
            ]

        endif
    endfor

    if len(proc_list)>0

        # sort, reverse, by user time
        shellout=""
        foreach p in proc_list
            nextline = format ("%v %v %v %v %v %v %v %v %v %v\n", p[0], p[1], key_p, p[2], p[3], p[4], p[5], p[6], p[7], p[8] )
            shellout = shellout + nextline
        endfor

        sorted = fieldsort(shellout,4,"n",true).lines(":17").uniq

        # final list display
        lcount=18
        comwidth=21

        at 1,1, format (  "[#b2][#7][#bold]%2s %8s %8s %5s %5s %7s %-{comwidth}s[##][#-]",
                                "st","ppid","pid","user","sys","threads","command" )

        clear(2,19,1)

        foreach p in sorted
            at 20-lcount,1
            fields(p," ")
            on proc_filter!="" and not match($lc F[10],$lc proc_filter) do continue
            # skip low activity processes
            # on float(F[4])<0.2 or float(F[5])<0.2 do continue
            on len(F[10])>=comwidth do F[10]=substr(F[10],0,comwidth-1)
            print format("%2s %8d %8d %5.0f %5.0f %7.0f [#6]%-{=comwidth-1}s[#-]",F[1],int(F[2]),int(F[3]),float(F[4]),float(F[5]),float(F[8]),collapse(F[10]))
            on lcount--==0 do break
        endfor

    endif
end


define humansize(i)
    unit="B"
    if i>=1e9; unit="GB"; i=float(i/1e9); endif
    if i>=1e6; unit="MB"; i=float(i/1e6); endif
    if i>=1e3; unit="KB"; i=float(i/1e3); endif
    return format("%.1f %s/sec",i,unit)
end

define hobbitsize(i)
    on i>=1e9 do return "%.1f G".format(float(i/1e9))
    on i>=1e6 do return "%.1f M".format(float(i/1e6))
    on i>=1e3 do return "%.1f K".format(float(i/1e3))
    return "%.1f ".format(i.float)
end


define showCpu(timeout,sample_start_in,showCpuDetails,showCpuBars,showCpuTotals)

    cursoroff()

    proc_file=""
    if is_file("/proc/stat")
        proc_file=$in "/proc/stat"
    else
        return sample_start_in
    endif

    on len(proc_file)==0 do return sample_start_in


    pane select "cpu"
    print linecolour; pane redraw

    activity_bg=" "
    activity_indicator="▪"
    on !utf8supported() do activity_indicator="-"

    row=1

    mult            = float(timeout)/10.0
    indexlist       = ["total","user","nice","sys","idle","iowait","irq","softirq","steal","guest"]
    partindexlist   = tail(indexlist)

    # init previous values for cpu stats

    foreach line in proc_file

        fields(line)
        on len(F)==0 do continue

        name=F[1]
        on kind(name)!="string" do continue
        on name=="cpu" do continue

        if match(name,"^cpu")

            # split up row
            f=F.tail
            # convert string values to floats
            f=f.list_float

            # read values from row
            vals["total"] = f.sum
            foreach i in partindexlist
                if f.head.is_number
                    vals[i]    = f.head
                else
                    vals[i]    = 0f
                endif
                on f.len>0 do f = f.tail
            endfor

            # set initial value for the global store
            if !globkey("prev","{name}_total")
                foreach i in indexlist
                    setglob prev["{name}_{i}"] = vals[i]
                endfor
            endif

            # now populate local prev from global prev
            foreach i in indexlist
                if globkey("prev","{name}_{i}")
                    g=prev["{name}_{i}"]
                    if g.is_number
                        one_prev[i]=g
                    else
                        one_prev[i]=0
                    endif
                else
                    one_prev[i]=0
                endif
            endfor

            # calc difference from last sample. -- units are USER_HZ, 1/100 sec
            if one_prev["total"]!=nil
                diff_total = float(vals["total"]-one_prev["total"])
                foreach i in partindexlist
                    if diff_total==0
                        diff[i]=int(0)
                    else
                        if is_number(one_prev[i])
                            diff[i] = ((vals[i]-int(one_prev[i])) / diff_total ) * mult
                        endif
                    endif
                endfor

                # figure display total
                subindexlist = ["user","nice","sys","iowait","irq","softirq","steal","guest"]
                disp_total=0.0
                foreach i in subindexlist
                    disp_total+=diff[i]
                endfor
            else
                at 2,2, "[#invert]Checking previous CPU values.[#-]"
                break foreach
            endif

            # record for next iter
            foreach i in indexlist
                setglob prev["{name}_{i}"] = vals[i]
            endfor

            # ensure positive and bounded
            if one_prev["total"]!=nil
                foreach i in partindexlist
                    on int(diff[i])<0   do diff[i]=0
                    on int(diff[i])>100 do diff[i]=100
                endfor
            endif
            
            # display
            if sample_start_in-->0
            else

                clear_line(row,1)

                at row,1 , format("[#7]%5s ",name)
                pos=7

                if showCpuDetails
                    at row,pos, format(
                                        "[#4]%3.0fus[#-], [#5]%3.0fsy[#-], [#1]%3.0fsi[#-], [#7]%3.0fhi[#-], [#3]%3.0fgu[#-], [#2]%3.0fst[#-], [#6]%3.0fio[#-]",
                                        float(diff["user"]),float(diff["sys"]),float(diff["softirq"]),
                                        float(diff["irq"]),float(diff["guest"]),float(diff["steal"]),float(diff["iowait"])
                                    )
                    pos=pos+59
                endif

                col_sys     = "[#5]";       w_sys     = diff["sys"]/2
                col_user    = "[#4]";       w_user    = diff["user"]/2
                col_idle    = "[#fbblue]";  w_idle    = diff["idle"]/2
                col_softirq = "[#1]";       w_softirq = diff["softirq"]/2
                col_irq     = "[#7]";       w_irq     = diff["irq"]/2
                col_guest   = "[#3]";       w_guest   = diff["guest"]/2
                col_steal   = "[#2]";       w_steal   = diff["steal"]/2
                col_iowait  = "[#6]";       w_iowait  = diff["iowait"]/2


                if showCpuBars
                    # fill cpu row background
                    at row,pos, pad(activity_indicator,-1,48,activity_bg)

                    # populate with values
                    at row,pos
                    print col_sys;      print pad(activity_indicator,1,w_sys.int,       activity_indicator)
                    print col_user;     print pad(activity_indicator,1,w_user.int,      activity_indicator)
                    print col_softirq;  print pad(activity_indicator,1,w_softirq.int,   activity_indicator)
                    print col_irq;      print pad(activity_indicator,1,w_irq.int,       activity_indicator)
                    print col_guest;    print pad(activity_indicator,1,w_guest.int,     activity_indicator)
                    print col_steal;    print pad(activity_indicator,1,w_steal.int,     activity_indicator)
                    print col_iowait;   print pad(activity_indicator,1,w_iowait.int,    activity_indicator)
                    print "[#-][##]"
                    pos=pos+49
                endif

                if showCpuTotals
                    cursorx(pos)
                    print format("❙ %4.2f",disp_total)
                endif

                row++

            endif

        endif
    endfor

    return sample_start_in

end


define showHdd()
    
    pane select "hdd"
    print linecolour; pane redraw

    cursoroff()

    when release_id()
    is "alpine"
        disks=< df -h | tail -n+2 | egrep '^overlay' | sort -grk5
    or
        disks=< df -h | tail -n+2 | egrep -v '^\/dev\/(loop.*|sr[0-9]+)' | sort -hrk5
    endwhen

    at 1,1, format("[#b2][#7][#bold]%20s %5s %5s %5s %-23s[#-][##]","path","size","used","avail","use%")
    row=2

    foreach d in disks
        if d!=""
            fields(d)
            on kind(F[1])!="string" do continue
            if !key("devices",F[1])
                devices[F[1]]=F[6]
                at row,1, format(`%20s %5s %5s %5s %-23s`,shorten(F[1],19),F[2],F[3],F[4],F[5])
                row++
            endif
        endif
    endfor

end


define showNet(net_sc,load,ipaddr,interface,timeout)

    cursoroff()

    if !is_file("/proc/net/dev")
        setglob net_sample_start_in-=1
        return 
    endif

    pane select "net"
    print linecolour; pane redraw

    at 2,4,"Interface [{interface}] Addr : {ipaddr} "

    at pane_h()-4,4,"[#6]", legload[0], "[#-] 64B-4Ki  [#6]", legload[1], "[#-] 4Ki-256Ki  [#6]", legload[2], "[#-] 256Ki-16Mi [#6]"
    at pane_h()-3,11,"[#6]", legload[3], "[#-] 16Mi-1Gi  [#6]", legload[4],"[#-] 1Gi-64Gi"

    foreach int_name in net_interfaces()

        int_filter=filter($in "/proc/net/dev","[ ]*"+int_name+":.*")
        on int_filter=="" do continue

        fields(int_filter)

        if has_start(int_name,interface)

            # current counters 
            rbytes  = float(F[2])
            tbytes  = float(F[10])

            # diff from previous
            drb=rbytes-prev_rbytes
            dtb=tbytes-prev_tbytes

            # shift left and append new to end
            setglob rblist=rblist.tail.append(drb)
            setglob tblist=tblist.tail.append(dtb)

            # display using log scale up to log64(5).
            # using key_timeout as a rough scaler for the sampling period.

            full_magnitude=5
            midline=8
           
            # traffic plots

            clear(3,7,1)
            clear(9,13,1)

            for f=2 to net_sc
                # recv plot
                sample=rblist[f-2].int
                if sample!=0
                    rsz=logn(sample,64).int
                    on rsz>full_magnitude do rsz=full_magnitude
                    if rsz>0
                        for brow=1 to rsz
                            at midline-brow,1+f , load[brow-1]
                        endfor
                    endif
                endif
                print "[#-]"

                # transmit plot
                sample=tblist[f-2].int
                if sample!=0
                    tsz=logn(sample,64).int
                    on tsz>full_magnitude do tsz=full_magnitude
                    if tsz>0
                        for brow=1 to tsz
                            at midline+brow,1+f , load[brow-1]
                        endfor
                    endif
                endif

                print "[#-]"

            endfor

            for e=1 to len(legload)
                at midline-e,1, "[#4]",legload[e-1],"[#-]"
                at midline+e,1, "[#1]",legload[e-1],"[#-]"
            endfor

            # write history
            setglob prev_rbytes = rbytes
            setglob prev_tbytes = tbytes

            # avg over a second:
            drb=humansize((1000/float(timeout))*drb)
            dtb=humansize((1000/float(timeout))*dtb)

            clear_line(pane_h()-1,1)
            at pane_h()-1,1, format("[#4] rx avg [#-] %v [#1] tx avg [#-] %v", drb, dtb)

        endif

    endfor

    setglob net_sample_start_in-=1
    return

end


define redef_layout(cpu_count,pfilter)

    #            name    row            col             h        w             title                            border
    pane define "cpu",    1,            1,         cpu_count+1,  150,  "[#b1]{=tink} Internal [##]",            "topline"
    pane define "hdd",    cpu_count+3,  2,              8,       64,   "[#b1]{=tink} Disks [##]",               "round"
    pane define "procs",  cpu_count+12, 2,              20,      64,   "[#b1]{=tink} Processes [##]"+pfilter,   "round"
    pane define "net",    cpu_count+3,  67,             19,      44,   "[#b1]{=tink} Network [##]",             "topline"
    pane define "envs",   cpu_count+23, 67,             13,      44,   "[#b1]{=tink} Environment [##]",         "topline"
    pane define "mem",    cpu_count+3,  112,            19,      34,   "[#b1]{=tink} Memory [##]",              "topline"
    pane define "files",  cpu_count+23, 112,            8,       34,   "[#b1]{=tink} Files [##]",               "topline"
    pane define "status", cpu_count+33, 1,              2,       150,  "",                                      "round"

    setglob net_sample_count = 40
    # on net_sample_count>72 do setglob net_sample_count = 72

    setglob rblist = push_front(0.0)
    setglob tblist = push_front(0.0)

    for f=1 to net_sample_count
        setglob rblist = append(rblist,0.0)
        setglob tblist = append(tblist,0.0)
    endfor

    showEnv()
            
    # origin line
    pane select "net"
    graph_line="-"
    on utf8supported() do graph_line="┈"
    midline=8
    at midline,2, "[#6]"
    for f=1 to net_sample_count
        print graph_line
    endfor
    print "[#-]"

end


#
# MAIN
# 

# in microseconds
key_timeout=1000000
timeout=key_timeout/1000

sample_start_in=4
net_sample_start_in=1

if winterm()
    interface="eth0"
else
    i =< ip -o -4 route show to default
    interface=field(i,5)
endif

linecolour="[#1]"
tink="[#5]"

ct=clktck()
if ct==0
    exit 1, "Could not find clock ticks."
endif

cls

user=get_env("USER")
on user=="" do user=<whoami
sudo=get_env("SUDO_USER")
access=true

if !(user=="root" || sudo!="")
    access=false
    println "Needs sudo for some information."
endif

# @todo: figure max cpu count automatically
cpu_count=get_cores()

# set up panes
w=term_w()
pfilter=""
redef_layout(cpu_count,pfilter)

# cpu history setup
var prev assoc

# net graph setup
prev_rbytes=0
prev_tbytes=0

# network load icons
legload = [ "❶", "❷", "❸", "❹", "❺" ]
load = [ "[#4]┃[#-]", "[#4]┃[#-]", "[#6]┃[#-]", "[#2]┃[#-]", "[#2]┉[#-]" ]

# main loop
ipaddr=interface_ip(interface)
quit=false

showCpuDetails=true
showCpuBars=true
showCpuTotals=true

iter=0
proc_filter=""
lt=epoch_nano_time()

while !quit

    iter++

    # in case of window change (sigwinch)
    if w!=term_w()
        cls
        w=term_w()
        redef_layout(cpu_count,pfilter)
    endif

    # capture system uptime
    on is_file("/proc/uptime") do uptime=float(field($in "/proc/uptime",1))

    # show panes
    sample_start_in=showCpu(timeout,sample_start_in,showCpuDetails,showCpuBars,showCpuTotals)
    showHdd()
    showNet(net_sample_count,load,ipaddr,interface,timeout)
    showProcs(ct,uptime)
    showFiles()
    showMem()

    # status area

    pane select "status"
    print linecolour; pane redraw

    clear(1,1,1)
    print "[#b1][#6]"

    t  = epoch_nano_time()
    d  = date_human(t/1_000_000_000)
    dt = float(t-lt) / 1_000_000
    lt = t

    at 1,1,ccformat("[#bold]%"+
            string(pane_w()-2)+
            "s[#boff][#-]",d+
            " | Current Timeout : {timeout} ms"
    )

    # get user input

    k=keypress(key_timeout)

    when char(k)
    is "i"
        clear(1,1,1); at 1,1
        prompt interface "Network Interface Name : " "^[a-zA-Z0-9]+$"
        ipaddr=interface_ip(interface)
    is "f"

        clear(1,1,1); at 1,1
        prompt proc_filter "New Filter (Leave empty to clear) : "
        pfilter=" ~ filter : [#i1][#2]"+proc_filter+"[#-][#i0] "
        pane select "procs"
        new_title="[#b1]{=tink} Processes [##]"
        on proc_filter!="" do new_title+=pfilter
        pane title new_title

    is "t"
        clear(1,1,1); at 1,1
        prompt timeout "New Timeout (ms) : " "^[0-9]+$"
        key_timeout=timeout.int*1000
    is "D"
        showCpuDetails = ! showCpuDetails
    is "B"
        showCpuBars=!showCpuBars
    is "T"
        showCpuTotals=!showCpuTotals
    is "q"
        quit=true
    is "h"
        clear(1,1,1)
        at 1,1, "(h) help  (t) timeout  (i) interface  (q) quit  "
        print "(D) cpu details  (B) cpu bars  (T) cpu totals  (f) filter"
        k=keypress(1500*1000)
        clear(1,1,1)
    endwhen

    cursoroff()
    print "[#-][##]"

endwhile

at term_h()-1,1
cursoron()


