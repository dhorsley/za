#!/usr/bin/za

#
# Test script for za.
# If this is working, the language probably is.
#
# This program displays a few pieces of key system 
# resource information on a single summary view.
#

#
# FUNCTIONS
#

logging on "/tmp/dh"

define clear(start,end,column)
    for f=start to end
        clear_line(f,column)
    endfor
enddef

define interface_ip(in)
    addrline =| ip addr show dev {in}
    ipaddr=replace(filter(addrline,"inet.*/"),"inet ","")
    ipaddr=replace(ipaddr,"/","")
    return ipaddr
enddef

define negreg(inp,matcher)
    out=""
    foreach l in inp
        if match(l,matcher); continue; endif
        out=out+l+"\n"
    endfor
    return out
enddef

test "fn_ip" group "mon" assert fail
    iip=interface_ip("lo:")
    assert start(iip,"127.0.0.")
endtest

define showEnv()
    pane select "envs"
    pane redraw
    clear(2,11,1)
    at  2,3; print "Hostname             : [#6]{hostname()}[#-]"
    at  3,3; print "Bash Version         : [#6]{bash_version()}[#-]"
    at  4,3; print "Bash Major Version   : [#6]{bash_versinfo()}[#-]"
    at  5,3; print "User                 : [#6]{user()}[#-]"
    at  6,3; print "OS                   : [#6]{os()}[#-]"
    at  7,3; print "Home                 : [#6]{home()}[#-]"
    at  8,3; print "Locale               : [#6]{lang()}[#-]"
    at  9,3; print "Distribution         : [#6]{release_name()}[#-]"
    at 10,3; print "Distribution ID      : [#6]{release_id()}[#-]"
    at 11,3; print "Distribution Version : [#6]{release_version()}[#-]"
enddef


define showFiles()

    if !winterm()

        open_fd=""
        open_inode=""

        on is_file("/proc/sys/fs/file-nr")  do open_fd    = read_file("/proc/sys/fs/file-nr")
        on is_file("/proc/sys/fs/inode-nr") do open_inode = read_file("/proc/sys/fs/inode-nr")

        on open_fd=="" || open_inode=="" do return

        pane select "files"
        pane redraw

        clear(1,4,1)

        ofd=field(open_fd,1,"\t")
        mfd=tr(open_fd,"d","\n")
        mfd=tr(mfd,"s","\t ")
        mfd=float(field(mfd,3,"\t "))
        at 2,2 ; print "Open Descr. : [#6]{ofd}[#-]"
        at 3,2 ; print "Max         : [#6]"
        if mfd>1e8
            print "No Limit[#-]"
        else
            print format("%.7g",mfd),"[#-]"
        endif
        fin=field(open_inode,2," \t\n")
        tin=float(field(open_inode,1," \t"))
        at 4,2 ; print "Free Inodes : [#6]{fin}[#-]"
        at 5,2 ; print "Total       : [#6]",format("%.7g",tin),"[#-]"

    endif

enddef


define showMem()

    pane select "mem"
    pane redraw

    if !getglob("access")
        at 2,1
        println "[#1]Slab information requires root access.[#-]"
        return
    endif

    # gather
   
    slab_file="" 
    on is_file("/proc/slabinfo") do slab_file=read_file("/proc/slabinfo")

    slabs=""
    if count(slab_file)>1
        foreach l in lines(slab_file,"2:")
            name=field(l,1," \t")
            s_sz=field(l,3," \t")
            s_cn=field(l,4," \t")
            on s_sz==0 || s_cn==0 do continue
            slabs=slabs+format("%s %3v\n",name,(float(s_sz)*float(s_cn))/1024/1024)
        endfor
        slabs=fieldsort(slabs,2,"n",true) 
    endif

    foreach f in ["total","free","avail","cached","active","swap_free","swap_total"]
        mem_{f}=0
    endfor

    if is_file("/proc/meminfo")
        foreach line in read_file("/proc/meminfo")
            fields(line)
            if F2!=""
                when F1
                    is "MemTotal:";     mem_total=F2
                    is "MemFree:";      mem_free=F2
                    is "MemAvailable:"; mem_avail=F2
                    is "Cached:";       mem_cached=F2
                    is "Active:";       mem_active=F2
                    is "SwapFree:";     mem_swap_free=F2
                    is "SwapTotal:";    mem_swap_total=F2
                endwhen
            endif
        endfor
    endif

    # display mem

    clear(2,9,1)
    at 2,2; print "Free Mem  : [#6]{mem_free}/{mem_total} KB[#-]"
    at 3,2; print "Avail Mem : [#6]{mem_avail} KB[#-]"
    at 4,2; print "Cached    : [#6]{mem_cached} KB[#-]"
    at 5,2; print "Active    : [#6]{mem_active} KB[#-]"
    at 6,2; print "Free Swap : [#6]{mem_swap_free}/{mem_swap_total} KB[#-]"

    # display slab info

    cs=8
    on count(slabs)<8 do cs=count(slabs)

    comwidth=10
    at 1,35; print format("[#b2][#7][#bold]%20s  %-{comwidth}s[##][#-]","slab allocatee","MB size")
    # would normally do with fields(). showing alternative below:
    if count(slabs)>0
        for p = 0 to cs-1
            l=lines(slabs,"{p}:{p}")
            sa=strpos(l," ",0)
            c1=substr(l,0,sa)
            c2=substr(l,sa+1,len(l)-sa-1)
            at 2+p,35; print format("%20s  [#6]%-"+comwidth+"d[#-]",c1,int(c2))
        endfor
    endif
enddef


define showProcs(ct,uptime)

    pane select "procs"
    pane redraw

    # get filenames
    procs =| ls -1 /proc/*/stat
    procs = line_filter(procs,"/[0-9]+/")

    proc_list=[]

    foreach p in procs
        on !is_file(p) do break
        ps = read_file(p)

        comm=tr(filter(ps,`\(.*?\)`),"d","()")
        ps=replace(ps,`\(.*?\)`,`"comm"`)

        # split up
        fields(ps)
        pid=int(F1)

        state=F3; ppid=F4
        utime=float(F14); stime=float(F15); cutime=float(F16); cstime=float(F17)
        priority=F18; nice=F19; threads=F20; procstarttime=float(F22)

        on kind(procstarttime)!="float64" || kind(utime)!="float64" || kind(stime)!="float64" do continue
        on kind(cstime)!="float64" || kind(cutime)!="float64" do continue

        on procstarttime==0 do continue

        # if not this process' pid (putime: seconds of process time) // putime==0 when proc just started.
        if pid!=pid()
            putime=float(uptime-(procstarttime/ct))
            on putime==0 do continue
            proc_list[pid]=[ state, ppid, 100*float(utime/ct/putime), 100*float(stime/ct/putime), 
                            100*float(cutime/ct/putime), 100*float(cstime/ct/putime), threads, procstarttime, gsub(comm," ","_") ]
        endif
    endfor

    if len(proc_list)>0

        # sort, reverse, by user time
        shellout=""
        foreach p in proc_list
            nextline = format ("%v %v %v %v %v %v %v %v %v %v\n", p[0], p[1], key_p, p[2], p[3], p[4], p[5], p[6], p[7], p[8] )
            shellout = shellout + nextline
        endfor

        sorted = uniq(lines(fieldsort(shellout,4,"n",true),":11"))

        # final list display
        count=8
        comwidth=25

        at 1,1; print format (  "[#b2][#7][#bold]%2s %6s %6s %5s %5s %7s %-{comwidth}s[##][#-]",
                                "st","ppid","pid","user","sys","threads","command" )

        clear(2,10,1)

        foreach p in sorted
            at 10-count,1
            fields(p," ")
            # skip low activity processes
            if float(F4)>0.2 || float(F5)>0.2
                on len(F10)>=comwidth do F10=substr(F10,0,comwidth-1)
                print format("%2s %6d %6d %5.0f %5.0f %7.0f [#6]%-{comwidth-1}s[#-]",F1,int(F2),int(F3),float(F4),float(F5),float(F8),collapse(F10))
                dec count
                on count==0 do break
            endif
        endfor

    endif
enddef


define humansize(i)
    unit="B"
    if i>=1e9; unit="GB"; i=float(i/1e9); endif
    if i>=1e6; unit="MB"; i=float(i/1e6); endif
    if i>=1e3; unit="KB"; i=float(i/1e3); endif
    return format("%.3f %s/sec",i,unit)
enddef


define showCpu(timeout,sample_start_in,showCpuDetails,showCpuBars,showCpuTotals)

    proc_file=""
    if is_file("/proc/stat")
        proc_file=read_file("/proc/stat")
    else
        return sample_start_in
    endif

    on len(proc_file)==0 do return sample_start_in


    pane select "cpu"
    pane redraw

    activity_indicator="·"
    on utf8supported()==false do activity_indicator="-"

    row=1

    mult            = float(timeout)/10.0
    indexlist       = ["total","user","nice","sys","idle","iowait","irq","softirq","steal","guest"]
    partindexlist   = tail(indexlist)

    # init previous values for cpu stats

    foreach line in proc_file

        fields(line)
        on len(F)==0 do continue

        name=F1
        on kind(name)!="string" do continue
        on name=="cpu" do continue

        if match(name,"^cpu")

            # split up row
            f=tail(F)
            # convert string values to floats
            f=list_float(f)

            # read values from row
            _total = sum(f)
            foreach i in partindexlist
                if is_number(head(f))
                    _{i}    = head(f)
                else
                    _{i}    = float(0)
                endif
                on len(f)>0 do f = tail(f)
            endfor

            # set initial value for the global store
            if !globkey("prev",string(name)+"_total")
                foreach i in indexlist
                    setglob prev["{name}_{i}"] = _{i}
                endfor
            endif

            # now populate local prev from global prev
            foreach i in indexlist
                if globkey("prev","{name}_{i}")
                    g=getglob(`prev["{name}_{i}"]`)
                    if is_number(g)
                        prev_{i}=g
                    else
                        prev_{i}=0
                    endif
                else
                    prev_{i}=0
                endif
            endfor

            # calc difference from last sample. -- units are USER_HZ, 1/100 sec
            if prev_total!=nil
                diff_total = float(_total-prev_total)
                foreach i in partindexlist
                    if diff_total==0
                        diff_{i}=int(0)
                    else
                        # if is_number(prev_{i})
                            diff_{i} = ((_{i}-int(prev_{i})) / diff_total ) * mult
                        # endif
                    endif
                endfor

                # figure display total
                disp_total=diff_user+diff_nice+diff_sys+diff_iowait+diff_irq+diff_softirq+diff_steal+diff_guest
            else
                # at 2,2; print "[#invert]Checking previous CPU values.[#-]"
                # break
            endif

            # record for next iter
            foreach i in indexlist
                setglob prev["{name}_{i}"] = _{i}
            endfor

            # ensure positive and bounded
            if prev_total!=nil
                foreach i in partindexlist
                    on int(diff_{i})<0   do diff_{i}=0
                    on int(diff_{i})>100 do diff_{i}=100
                endfor
            endif
            
            # display

            if sample_start_in>0
                sample_start_in=sample_start_in-1
            else

                clear_line(row,1)


                at row,1 ; print format("%5s ",name)
                pos=7

                if showCpuDetails
                    at row,pos; print format(
                                        "[#4]%3.0fus[#-], [#5]%3.0fsy[#-], [#1]%3.0fsi[#-], [#7]%3.0fhi[#-], [#3]%3.0fgu[#-], [#2]%3.0fst[#-], [#6]%3.0fio[#-]",
                                        float(diff_user),float(diff_sys),float(diff_softirq),float(diff_irq),float(diff_guest),float(diff_steal),float(diff_iowait)
                                    )
                    inc pos 59
                endif

                col_sys     = "[#b5]"; w_sys      = diff_sys/2
                col_user    = "[#b4]"; w_user     = diff_user/2
                col_idle    = "[#b0]"; w_idle     = diff_idle/2
                col_softirq = "[#b1]"; w_softirq  = diff_softirq/2
                col_irq     = "[#b7]"; w_irq      = diff_irq/2
                col_guest   = "[#b3]"; w_guest    = diff_guest/2
                col_steal   = "[#b2]"; w_steal    = diff_steal/2
                col_iowait  = "[#b6]"; w_iowait   = diff_iowait/2


                if showCpuBars
                    # fill cpu row background
                    at row,pos
                    # cursorx(pos)
                    print pad(activity_indicator,-1,48,activity_indicator)

                    # populate with values
                    at row,pos
                    #cursorx(pos)
                    print col_sys;      print pad(activity_indicator,1,w_sys,activity_indicator)
                    print col_user;     print pad(activity_indicator,1,w_user,activity_indicator)
                    print col_softirq;  print pad(activity_indicator,1,w_softirq,activity_indicator)
                    print col_irq;      print pad(activity_indicator,1,w_irq,activity_indicator)
                    print col_guest;    print pad(activity_indicator,1,w_guest,activity_indicator)
                    print col_steal;    print pad(activity_indicator,1,w_steal,activity_indicator)
                    print col_iowait;   print pad(activity_indicator,1,w_iowait,activity_indicator)
                    print "[##]"
                    inc pos 49
                endif

                if showCpuTotals
                    cursorx(pos)
                    print format("❙ %4.2f",disp_total)
                endif

                inc row

            endif

        endif
    endfor

    return sample_start_in

enddef


define showHdd()
    
    pane select "hdd"
    pane redraw

    when release_id()
    is "alpine"
        disks=| df -h | tail -n+2 | egrep '^overlay' | sort -grk5
    or
        disks=| df -h | tail -n+2 | egrep -v '^\/dev\/(loop.*|sr[0-9]+)' | sort -hrk5
    endwhen

    comwidth=23
    at 1,1; print format("[#b2][#7][#bold]%20s %5s %5s %5s %-{comwidth}s[#-][##]","path","size","used","avail","use%")
    row=2

    foreach d in disks
        if d!=""
            fields(d)
            on kind(F1)!="string" do continue
            if !key("devices",F1)
                devices[F1]=F6
                at row,1; print format("%20s %5s %5s %5s [#6]%-{comwidth}s[#-]",F1,F2,F3,F4,F5)
                inc row
            endif
        endif
    endfor

enddef


define showNet(net_sample_count,net_sample_start_in,load,ipaddr,interface,timeout)

    if !is_file("/proc/net/dev")
        return net_sample_start_in-1
    endif

    pane select "net"
    pane redraw

    at 1,2
    print "Interface [{interface}] Address : {ipaddr}        "

    at pane_h()-3,2
    print "Legend [#6]", load[0], "[#-] 64B-4KiB [#6]", load[1], "[#-] 4KiB-256KiB [#6]"
    print load[2], "[#-] 256KiB-16MiB [#6]", load[3], "[#-] 16MiB-1GiB [#6]", load[4],"[#-] 1GiB-64GiB"

    foreach int_name in net_interfaces()

        int_filter=filter(read_file("/proc/net/dev"),"[ ]*"+int_name+":.*")
        on int_filter=="" do continue

        fields(int_filter)

        if start(int_name,interface)

            # current counters 
            rbytes  = float(F2)
            rerr    = float(F4)
            tbytes  = float(F10)
            terr    = float(F12)

            # diff from previous
            if net_sample_start_in>0
                setglob prev_rbytes = rbytes
                setglob prev_rerr = rerr
                setglob prev_tbytes = tbytes
                setglob prev_terr = terr
            endif

            drb=float(rbytes-getglob("prev_rbytes"))
            dre=float(rerr-getglob("prev_rerr"))
            dtb=float(tbytes-getglob("prev_tbytes"))
            dte=float(terr-getglob("prev_terr"))

            # shift left and append new to end
            rblist=append(tail(getglob("rblist")),drb)
            relist=append(tail(getglob("relist")),dre)
            tblist=append(tail(getglob("tblist")),dtb)
            telist=append(tail(getglob("telist")),dte)

            # display using log scale up to log64(5).
            # using key_timeout as a rough scaler for the sampling period.
            # skip displaying errors. just show in/out bytes

            full_magnitude=5
            midline=7
           
            # traffic plots

            clear(3,6,1)
            clear(8,11,1)

            for f=1 to net_sample_count
                
                # recv plot
                print "[#invert][#4]"
                rsz=0
                sample=int(rblist[f])
                if sample!=0
                    rsz=int(log(sample,64))
                    on rsz>full_magnitude do rsz=full_magnitude
                    if rsz>0 ; at midline-(rsz),1+f ; print load[rsz-1] ; endif
                endif
                print "[#-]"

                # transmit plot
                print "[#invert][#1]"
                tsz=0
                sample=int(tblist[f])
                if sample!=0
                    tsz=int(log(sample,64))
                    on tsz>full_magnitude do tsz=full_magnitude
                    if tsz>0 ; at midline+(tsz),1+f ; print load[tsz-1] ; endif
                endif

                print "[#-]"

            endfor

            # write history
            setglob rblist = rblist
            setglob relist = relist
            setglob tblist = tblist
            setglob telist = telist

            setglob prev_rbytes = rbytes
            setglob prev_tbytes = tbytes
            setglob prev_rerr = rerr
            setglob prev_terr = terr

            # avg over a second:
            drb=humansize((1000/float(timeout))*drb)
            dtb=humansize((1000/float(timeout))*dtb)

            clear_line(pane_h()-1,2)
            at pane_h()-1,2
            print format("[#bbred][#7] %v [#-][##]  [#b4][#1] rx avg [#-][##] %v  [#b1][#3] tx avg [#-][##] %v", int_name, drb, dtb)

        endif

    endfor

    return net_sample_start_in-1

enddef


define redef_layout(cpu_count)

    #            name    row            col             h        w             title                      border
    pane define "cpu",    1,            1,         cpu_count+1,  term_w(),     "[#b1] Internal [##]",    "none"
    pane define "hdd",    cpu_count+3,  2,              6,       64,           "[#b1] Disks [##]",       "round"
    pane define "procs",  cpu_count+10, 2,              11,      64,           "[#b1] Processes [##]",   "round"
    pane define "net",    cpu_count+3,  66,             18,      term_w()-67,  "[#b1] Network [##]",     "none"
    pane define "envs",   cpu_count+22, 1,              13,      50,           "[#b1] Environment [##]", "topline"
    pane define "mem",    cpu_count+22, 51,             13,      70,           "[#b1] Memory [##]",      "topline"
    pane define "files",  cpu_count+22, 121,            13,      term_w()-120, "[#b1] Files [##]",       "topline"
    pane define "status", cpu_count+36, 1,              4,       term_w(),     "[#b1] Status [##]",      "none"

    setglob net_sample_count = term_w()-71

    setglob rblist = push_front(0.0)
    setglob relist = push_front(0.0)
    setglob tblist = push_front(0.0)
    setglob telist = push_front(0.0)

    for f=1 to getglob("net_sample_count")
        setglob rblist = append(getglob("rblist"),0.0)
        setglob relist = append(getglob("relist"),0.0)
        setglob tblist = append(getglob("tblist"),0.0)
        setglob telist = append(getglob("telist"),0.0)
    endfor

    showEnv()
            
    # origin line
    pane select "net"
    graph_line="-"
    on utf8supported() do graph_line="┈"
    midline=7
    print "[#6]"
    at midline,2
        # at midline,1+f; print graph_line
    for f=1 to getglob("net_sample_count")
        print graph_line
    endfor
    print "[#-]"

enddef


#
# MAIN
# 

# in microseconds
key_timeout=1000000
timeout=key_timeout/1000

sample_start_in=4
net_sample_start_in=1

if winterm()
    interface="eth0"
else
    i =| ip -o -4 route show to default
    interface=field(i,5)
endif

ct=clktck()
if ct==0
    println "Could not find clock ticks."
    exit 1
endif

cls

user=get_env("USER")
on user=="" do user=|whoami
sudo=get_env("SUDO_USER")
access=true

if !(user=="root" || sudo!="")
    access=false
    println "Needs sudo for some information."
endif

# @todo: figure max cpu count automatically
cpu_count=getcores()

# set up panes
w=term_w()
redef_layout(cpu_count)


# cpu history setup
init prev assoc

# net graph setup
prev_rbytes=0
prev_tbytes=0
prev_rerr=0
prev_terr=0

# network load icons
load = [ "1", "2", "3", "4", "5" ]

# main loop
ipaddr=interface_ip(interface)
quit=false

showCpuDetails=true
showCpuBars=true
showCpuTotals=true

iter=0

while !quit

    inc iter

    # in case of window change (sigwinch)
    if w!=term_w()
        cls
        w=term_w()
        redef_layout(cpu_count)
    endif

    # capture system uptime
    on is_file("/proc/uptime") do uptime=float(field(read_file("/proc/uptime"),1))

    # show panes
    sample_start_in=showCpu(timeout,sample_start_in,showCpuDetails,showCpuBars,showCpuTotals)
    showHdd()
    net_sample_start_in=showNet(net_sample_count,net_sample_start_in,load,ipaddr,interface,timeout)
    showProcs(ct,uptime)
    showFiles()
    showMem()

    # status area

    pane select "status"
    pane redraw

    print "[#b1]"
    clear(1,3,1)

    d=|date
    at 1,2; print "[#bold]",d
    timo=string(timeout)
    at 2,2; print "Current Timeout : {timo} ms"

    # get user input
    k=keypress(key_timeout)

    at 2,1
    when chr(k)
    is "i"
        prompt interface "Network Interface Name : " "^[a-zA-Z0-9]+$"
        ipaddr=interface_ip(interface)
    is "t"
        prompt timeout "New Timeout (ms) : " "^[0-9]+$"
    is "D"
        showCpuDetails = ! showCpuDetails
    is "B"
        showCpuBars=!showCpuBars
    is "T"
        showCpuTotals=!showCpuTotals
    is "q"
        quit=true
    is "h"
        clear_line(2,1)
        at 2,1; print "(h) help  (t) timeout  (i) interface  (q) quit"
        at 3,1; print "(D) Cpu Details  (B) Cpu Bars  (T) Cpu Totals"
        k=keypress(1500*1000)
        clear_line(2,1)
    endwhen

    cursoroff()
    print "[#-][##]"

endwhile

at term_h()-1,1
cursoron()


