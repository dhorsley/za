#!/usr/bin/za

doc `
    simple todo list example
`

# functions

def save(tasks,saveloc)
    saved=false
    h=fopen(saveloc,"w")
    if h!=nil
        foreach e in tasks
            fwrite(h,"{=e.name}\n{=e.description}\n{=e.status}\n{=e.start_date}\n")
        endfor
        fclose(h)
        saved=true
    endif
    return saved
end

def load(saveloc)
    opened=false
    h=fopen(saveloc,"r")
    if h!=nil
        var tasks []any
        while !feof(h)
            name=fread(h,"\n")
            desc=fread(h,"\n")
            status=fread(h,"\n").as_int
            start_date=fread(h,"\n").as_int
            append_to(ref tasks,task(name,desc,status,start_date))
        endwhile
        fclose(h)
        opened=true
    endif
    return tasks,opened
end

def cleanup()
    tui_screen(0)
    saved=save(tasks,saveloc)
    if saved
        footer("[#4]tasks saved to %s[#-]".format(saveloc))
    else
        footer("[#2]tasks not saved to %s[#-]".format(saveloc))
    endif
    println
    cursoron()
    at term_h(),1
    exit
end

def footer(s)
    clear_line(term_h(),1)
    at term_h(),1, s
end

def resize()
    @colSize=as_int(term_w()-4)/headers.len
    @rec.Width=colSize
    @intui.Width=term_w()

    for e=0 to term_h()-1
        clear_line(e,1)
    endfor
    tui_screen(1)

    # column headers
    foreach c in enum_all("status")
        at colStartPos-2,startColX+key_c*rec.Width+(rec.Width/2-headers[c].len/2),"[#bold][#ul]{=headers[c]}[#-]"
    endfor

    # top option line display
    at 1,1, "[#b1][#7] Todo Editor [##][#-]   [#5]e[#-]dit  [#5]d[#-]elete  [#5]u[#-]ndelete  [#5]n[#-]ew  [#5]t[#-]ouch  [#5]q[#-]uit   [#i1]shift-left/right to move a task.[#i0]"

    @TW=term_w()
end

# definitions

enum status ( backlog=0, todo, inprogress, onhold, done )

struct task
    name        string
    description string
    status      int
    start_date  int
endstruct


# main

# setup task list
saveloc=home()+"/.tui_board"
var tasks []any

loaded=false
if is_file(saveloc)
    tasks,loaded=load(saveloc)
    if loaded
        footer("tasks loaded from %s".format(saveloc))
        println
    endif
endif 

if !loaded
    append_to(ref tasks, task(.name "feed cats",        .description "give the cats their food",            .status status.inprogress, .start_date 1723761115 ))
    append_to(ref tasks, task(.name "fill water bowls", .description "water only, they get too much milk",  .status status.done,       .start_date 1723761115 ))
    append_to(ref tasks, task(.name "hunt furballs",    .description "they like to leave little presents",  .status status.todo,       .start_date 0          ))
    append_to(ref tasks, task(.name "fluff cat beds",   .description "they demand comfort",                 .status status.todo,       .start_date 0          ))
    footer("example tasks created")
endif


# create column headers
var headers map
headers[status.backlog]="Backlog"
headers[status.todo]="To Do"
headers[status.inprogress]="In Progress"
headers[status.onhold]="On Hold"
headers[status.done]="Complete"

# switch to alt screen
tui_screen(1)
TW=term_w()

# create input element
intui=tui_new() 
instyle=tui_new_style()
intui.Row,intui.Col=[2,1]
intui.Height,intui.Width=[1,term_w()]

# setup reusable style
s=tui_new_style()
s.fill=true
border=s.border
s.bg,s.fg       =["1","7"]
s.hi_bg,s.hi_fg =["2","7"]
border["fg"]="5"
s.border=border
s.wrap=true

# screen dimensioning
colSize=as_int(term_w()-4)/headers.len
startColX=3

# instantiate record template
tmpl="[#bold][#5]{.name}[#boff][#-]\n[#i1]{.description}[#i0]"
rec=tui_new()
rec.Height,rec.Width=[5,colSize]
rec.Border=true

# cursor setup and limit tracking
optcol=0
optrow=0
colStartPos=5
maxCol=enum_all("status").len-1
var coldepths []int

# var maxdepths []int
# maxdepths[status.todo]=0
# maxdepths[status.inprogress]=5
# maxdepths[status.done]=0
# @todo: display these limits as columns breaks, but
#        don't actually limit the card counts yet.

# setup mapping between on screen lists and the task array
var task_index map

# setup deletion undo buffer
undoLen=0
maxUndo=10
var undo []any

resize()

# key input loop
quit=false
while not quit

    on TW!=term_w() do resize()

    cursoroff()
    foreach c in enum_all("status")
        ypos=0
        foreach t in tasks
            task_index["{ypos},{c}"]=key_t
            if t.status==c
                s.bg="0"
                if ypos==optrow and c==optcol
                    s.bg="2"
                endif
                rec.Row,rec.Col=[colStartPos+(rec.Height+1)*ypos,startColX+key_c*rec.Width]
                rec.Content=tmpl
                rec.Data=t
                rec.tui_box(s)
                if c in [status.inprogress,status.onhold]
                    dateline="[#invert][#4] Started: "+date_human(t.start_date).replace(" \+.*$","")+" [#-]"
                    dl=dateline.stripcc.len
                    at rec.Row+rec.Height,rec.Col+rec.Width-dl-2,dateline
                endif
                rec.tui_template(s)
                ypos++
            endif
        endfor
        coldepths[c]=ypos

        # clear one more at the bottom of each column, in case a record was just moved
        rec.Row,rec.Col=[colStartPos+(rec.Height+1)*ypos,startColX+key_c*rec.Width]
        rec.tui_clear(s)

        if coldepths[c]==0
            # highlight empty row
            at colStartPos+5,startColX+key_c*rec.Width
            emptySelected=""
            on optcol==c do emptySelected="[#invert]"
            print pad("{emptySelected}[#2]<empty>[#-]",0,rec.Width)
        endif
    endfor


    k=keypress(0)

    case k

    has k in [8,asc("h")] # left
        if optcol>0
            optcol--
            optrow=optrow[0:coldepths[optcol]-1]
        endif

    has k in [9,asc("l")] # right
        if optcol<maxCol
            optcol++
            optrow=optrow[0:coldepths[optcol]-1]
        endif

    has k in [10,asc("j")] # down
        on optrow<coldepths[optcol]-1 do optrow++

    has k in [11,asc("k")] # up
        on optrow>0 do optrow--

    is 208 # shift left
        if optcol>0 and coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            if optcol==status.inprogress
                tasks[selected].start_date=0
            endif
            tasks[selected].status-=1
            rec.Row,rec.Col=[colStartPos+(rec.Height+1)*optrow,startColX+optcol*(rec.Width)]
            footer("Moved [#bold]%s[#boff] from [#i1]%s[#i0] to [#i1]%s[#i0]".
                format(tasks[selected].name,headers[optcol],headers[optcol-1])
            )
            rec.tui_clear(s)
            optcol--
            optrow=optrow[0:coldepths[optcol]]
        endif
    is 209 # shift right
        if optcol<maxCol and coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            if optcol==status.todo and tasks[selected].start_date==0
                tasks[selected].start_date=epoch_time()
            endif
            tasks[selected].status+=1
            rec.Row,rec.Col=[colStartPos+(rec.Height+1)*optrow,startColX+optcol*(rec.Width)]
            footer("Moved [#bold]%s[#boff] from [#i1]%s[#i0] to [#i1]%s[#i0]".
                format(tasks[selected].name,headers[optcol],headers[optcol+1])
            )
            rec.tui_clear(s)
            optcol++
            optrow=optrow[0:coldepths[optcol]]
        endif

    has k in [27,asc("q")]
        quit=true

    is asc("t") # touch date
        selected=task_index["{optrow},{optcol}"]
        on tasks[selected].start_date!=0 do tasks[selected].start_date=epoch_time() 

    is asc("n") # new task

        intui.Prompt="New task name : "
        name=intui.tui_input(instyle).Result
        intui.Prompt="New task description : "

        desc=intui.tui_input(instyle).Result
        intui.tui_clear(instyle)

        append_to(ref tasks, task(.name name, .description desc, .status status.todo))
        footer("[#bold]%s[#boff] task added".format(name))

    is asc("d") # delete task under cursor

        if coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            name=tasks[selected].name

            on undoLen==maxUndo-1 do undo=undo[1:undoLen]
            undo[undoLen]=tasks[selected]
            undoLen++
            tasks=tasks[:selected]+tasks[selected+1:]
            on optrow >= coldepths[optcol]-1 do optrow--
            on optrow < 0 do optrow=0
            coldepths[optcol]-=1
            footer("[#bold]%s[#boff] task deleted".format(name))
        else
            footer("nothing to delete in column [#i1]%s[#i0]".format(headers[optcol]))
        endif

    is asc("e") # edit task under cursor

        if coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            intui.Prompt="New task name : "
            intui.Content=tasks[selected].name
            name=intui.tui_input(instyle).Result

            intui.Prompt="New task description : "
            intui.Content=tasks[selected].description
            desc=intui.tui_input(instyle).Result

            intui.tui_clear(instyle)
            tasks[selected].name=name
            tasks[selected].description=desc

            footer("[#bold]%s[#boff] task amended".format(name))
        else
            footer("nothing to edit")
        endif

    is asc("u") # undo last
        if undoLen>0 
            append_to(ref tasks, undo[undoLen-1])
            undoLen--
            footer("undo applied to task [#bold]%s[#boff]".format(undo[undoLen].name))
        endif

    endcase

endwhile

cleanup()

