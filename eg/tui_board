#!/usr/bin/za

doc `
    simple todo list example
`

# functions

def save(tasks,saveloc)
    saved=false
    h=fopen(saveloc,"w")
    if h!=nil
        foreach e in tasks
            fwrite(h,"{=e.name}\n{=e.description}\n{=e.status}\n")
        endfor
        fclose(h)
        saved=true
    endif
    return saved
end

def load(saveloc)
    opened=false
    h=fopen(saveloc,"r")
    if h!=nil
        var tasks []any
        while !feof(h)
            name=fread(h,"\n")
            desc=fread(h,"\n")
            status=fread(h,"\n").as_int
            append_to(ref tasks,task(name,desc,status))
        endwhile
        fclose(h)
        opened=true
    endif
    return tasks,opened
end

def cleanup()
    tui_screen(0)
    saved=save(tasks,saveloc)
    if saved
        footer("[#4]tasks saved to %s[#-]".format(saveloc))
    else
        footer("[#2]tasks not saved to %s[#-]".format(saveloc))
    endif
    println
    cursoron()
    at term_h(),1
    exit
end

def footer(s)
    clear_line(term_h(),1)
    at term_h(),1, s
end

def resize()
    @colSize=as_int(term_w()-4)/3
    @rec.Width=colSize
    @intui.Width=term_w()

    cls
    tui_screen(1)

    # column headers
    foreach c in enum_all("status")
        at colStartPos-2,startColX+key_c*rec.Width+(rec.Width/2-headers[c].len/2),"[#bold][#ul]{=headers[c]}[#-]"
    endfor

    # top option line display
    at 1,1, "[#b1][#7] Todo Editor [##][#-]   [#1]e[#-]dit  [#1]d[#-]elete  [#1]u[#-]ndo  [#1]n[#-]ew  [#1]q[#-]uit   [#i1]shift-left and shift-right to move a task or move around with cursor keys.[#i0]"

    @TW=term_w()
end

# definitions

enum status ( todo=0, inprogress, done )

struct task
    name        string
    description string
    status      int
endstruct


# main

# setup task list
saveloc=home()+"/.tui_board"
var tasks []any

loaded=false
if is_file(saveloc)
    tasks,loaded=load(saveloc)
    if loaded
        footer("tasks loaded from %s".format(saveloc))
        println
    endif
endif 

if !loaded
    append_to(ref tasks, task(.name "feed cats",        .description "give the cats their food",            .status status.inprogress   ))
    append_to(ref tasks, task(.name "fill water bowls", .description "water only, they get too much milk",  .status status.done         ))
    append_to(ref tasks, task(.name "hunt furballs",    .description "they like to leave little presents",  .status status.todo         ))
    append_to(ref tasks, task(.name "fluff catbeds",    .description "they demand comfort",                 .status status.todo         ))
    footer("example tasks created")
endif


# create column headers
var headers map
headers[status.todo]="To Do"
headers[status.inprogress]="In Progress"
headers[status.done]="Complete"

# switch to alt screen
tui_screen(1)
TW=term_w()

# create input element
intui=tui_new() 
instyle=tui_new_style()
intui.Row,intui.Col=[2,1]
intui.Height,intui.Width=[1,term_w()]

# setup reusable style
s=tui_new_style()
s.fill=true
border=s.border
s.bg,s.fg       =["1","7"]
s.hi_bg,s.hi_fg =["2","7"]
border["fg"]="5"
s.border=border
s.wrap=true

# screen dimensioning
colSize=as_int(term_w()-4)/3
startColX=3

# instantiate record template
tmpl="[#bold][#3]{.name}[#boff][#-]\n[#7]{.description}[#-]"
rec=tui_new()
rec.Height,rec.Width=[4,colSize]
rec.Border=true

# cursor setup and limit tracking
optcol=0
optrow=0
colStartPos=5
maxCol=enum_all("status").len-1
var coldepths []int

# setup mapping between on screen lists and the task array
var task_index map

# setup undo buffer
undoLen=0
maxUndo=10
var undo []any

resize()

# key input loop
quit=false
while not quit

    on TW!=term_w() do resize()

    cursoroff()
    foreach c in enum_all("status")
        ypos=0
        foreach t in tasks
            task_index["{ypos},{c}"]=key_t
            if t.status==c
                s.bg="0"
                if ypos==optrow and c==optcol
                    s.bg="2"
                endif
                rec.Row,rec.Col=[colStartPos+5*ypos,startColX+key_c*(rec.Width)]
                rec.Content=tmpl
                rec.Data=t
                rec.tui_box(s)
                rec.tui_template(s)
                ypos++
            endif
        endfor
        coldepths[c]=ypos
        if coldepths[c]==0
            # highlight empty row
            at colStartPos+5,startColX+key_c*(rec.Width)
            emptySelected=""
            on optcol==c do emptySelected="[#invert]"
            print pad("{emptySelected}[#2]<empty>[#-]",0,rec.Width)
        endif
        # clear one more at the bottom of each column, in case a record was just moved
        rec.Row,rec.Col=[colStartPos+5*ypos,startColX+key_c*(rec.Width)]
        rec.tui_clear(s)
    endfor

    # at 1,1

    k=keypress(0)
    
    # left, right : switch lists
    # up, down    : move cursor in list
    # shift-right, shift-left : move item between lists
    # esc,q : quit
    # n : new item

    case k

    has k in [8,asc("h")] # left
        if optcol>0
            optcol--
            optrow=optrow[0:coldepths[optcol]-1]
        endif

    has k in [9,asc("l")] # right
        if optcol<maxCol
            optcol++
            optrow=optrow[0:coldepths[optcol]-1]
        endif

    has k in [10,asc("j")] # down
        on optrow<coldepths[optcol]-1 do optrow++

    has k in [11,asc("k")] # up
        on optrow>0 do optrow--

    is 208 # shift left
        if optcol>0 and coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            tasks[selected].status-=1
            rec.Row,rec.Col=[colStartPos+5*optrow,startColX+optcol*(rec.Width)]
            footer("Moved [#bold]%s[#boff] from [#i1]%s[#i0] to [#i1]%s[#i0]".
                format(tasks[selected].name,headers[optcol],headers[optcol-1])
            )
            rec.tui_clear(s)
            optcol--
            optrow=optrow[0:coldepths[optcol]]
        endif
    is 209 # shift right
        if optcol<maxCol and coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            tasks[selected].status+=1
            rec.Row,rec.Col=[colStartPos+5*optrow,startColX+optcol*(rec.Width)]
            footer("Moved [#bold]%s[#boff] from [#i1]%s[#i0] to [#i1]%s[#i0]".
                format(tasks[selected].name,headers[optcol],headers[optcol+1])
            )
            rec.tui_clear(s)
            optcol++
            optrow=optrow[0:coldepths[optcol]]
        endif

    has k in [27,asc("q")]
        quit=true

    is asc("n") # new task

        intui.Prompt="New task name : "
        name=intui.tui_input(instyle).Result
        intui.Prompt="New task description : "

        desc=intui.tui_input(instyle).Result
        intui.tui_clear(instyle)

        append_to(ref tasks, task(.name name, .description desc, .status status.todo))
        footer("[#bold]%s[#boff] task added".format(name))

    is asc("d") # delete task under cursor

        if coldepths[optcol]>0
            selected=task_index["{optrow},{optcol}"]
            name=tasks[selected].name

            on undoLen==maxUndo-1 do undo=undo[1:undoLen]
            undo[undoLen]=tasks[selected]
            undoLen++
            tasks=tasks[:selected]+tasks[selected+1:]
            on optrow >= coldepths[optcol]-1 do optrow--
            on optrow < 0 do optrow=0
            coldepths[optcol]-=1
            footer("[#bold]%s[#boff] task deleted".format(name))
        else
            footer("nothing to delete in column [#i1]%s[#i0]".format(headers[optcol]))
        endif

    is asc("e") # edit task under cursor

        selected=task_index["{optrow},{optcol}"]

        intui.Prompt="New task name : "
        intui.Content=tasks[selected].name
        name=intui.tui_input(instyle).Result

        intui.Prompt="New task description : "
        intui.Content=tasks[selected].description
        desc=intui.tui_input(instyle).Result

        intui.tui_clear(instyle)
        tasks[selected].name=name
        tasks[selected].description=desc

        footer("[#bold]%s[#boff] task amended".format(name))

    is asc("u") # undo last
        if undoLen>0 
            append_to(ref tasks, undo[undoLen-1])
            undoLen--
            footer("undo applied to task [#bold]%s[#boff]".format(undo[undoLen].name))
        endif

    endcase

endwhile

# cleanup
cleanup()

