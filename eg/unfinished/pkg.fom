#!/usr/bin/za -f

define error(err,str)
    print "[#2]{str}\n"
    exit err
enddef

define title(ve)
    print "\n[#6][#bold]pkg - v{ve}\n"
    exit 0
enddef

define get_config(za,key)
    fc="{za}/.za/config"
    if ! is_file(fc)
        return nil,"configuration file not found"
    endif
    val = get_value(fc,key)
    # val =| grep -Eo "^[[:space:]]*{key}[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$" {fc} 2>/dev/null | cut -d= -f2
    return val,"value returned"
enddef


## Procedure: daemon()
#-   take script file #1 and execute it in the background.
#-   the execution should be detached from it's parent pid on startup.
## Params: #1  : script file
define daemon(dfile)
    print "(daemon)\n"
    print "Launching {dfile} in the background and disowning it.\n"
    | chmod 700 {dfile}
    | ( exec </dev/null && exec >> daemon.log && exec 2>> daemon.log && exec setsid {dfile} ; ) & disown
    #    might need to be :    ; ) & disown
    return last()
enddef

## Procedure: sequencer()
#-   execute all scripts in the 'sequenced' directory sequentially.
#-   scripts are ordered by their filename prefixes numerically.
define sequencer(soe)

    print "(sequencer)\n"

    # get file list
    filelist =| mktemp -p {~downloads}
    | ls -1 sequenced | sort -n -t- -k1 -o {filelist}
 
    # process list
    cnt=0
    foreach fn in read_file(filelist)

        cnt=cnt+1
        name =| echo "{fn}" | cut -f2- -d-

        #  execute script
        print "Executing sequence pattern {cnt} : "
        | sequenced/{fn}
        code=last()
        print
        if code != 0
            if soe
                return code,"Error: pattern file {fn} failed. Exiting."
            endif
        endif 

    endfor

    print "All sequence patterns executed!\n"
    return 0,"Complete"

enddef

