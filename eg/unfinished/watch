#!/usr/bin/za

doc `
    Description:
        This example script is for monitoring a configured set of directories
         for file changes (new/removed/modified) and taking an action on detection.
        It is currently non-recursive and ignores directory name entries.
        Permitted actions will include:
            1) moving files on change
            2) deleting files on change
            3) copying files on change
    Status:
        NEAR COMPLETE
            Requires logging and quiet modes/functions.
            Maybe could add recursive copies.
            Possibly add separate destinations per source.
`

#
# FUNCTIONS
#

module "mod_watch/general"
module "mod_watch/file"


# build change list for directory 'd' and perform configured actions on change
define check_dir(conf,d)

    # build current file list
    new_names=[]
    foreach f in dir(d,conf.filter)
        on f.isdir do continue
        file_list=append(file_list,f)
        new_names=append(new_names,f.name)
    endfor

    # build prev name list
    old_names=[]
    foreach f in conf.prev
        old_names=append(old_names,f.name)
    endfor

    # allow for a warm up period to generate a previous sample.
    if !conf.starting

        # new files?
        new_files=[]
        foreach fn in new_names
            on has(old_names,fn) do continue
            new_files=append(new_files,fn)
        endfor

        # removed files?
        rem_files=[]
        foreach fn in old_names
            on has(new_names,fn) do continue
            rem_files=append(rem_files,fn)
        endfor

        # modified files? (timestamp)
        # modified files? (size)

        cp=conf.prev
        mod_files_time=[]
        mod_files_size=[]
        foreach f in file_list
            on !has(old_names,f.name) do continue
            of=lookup_old(conf,f.name)
            if of>-1
                p_rec=cp[of]
                if p_rec.mtime != f.mtime
                    # println ": -- [#3]time diff[#-] in {=p_rec.name}"
                    mod_files_time=append(mod_files_time,p_rec.name)
                endif
                if p_rec.size != f.size
                    # println ": -- [#3]size diff[#-] in {=p_rec.name}"
                    if !has(mod_files_time,p_rec.name)
                        # only add to modified size files list if not
                        # already in modified times list.
                        mod_files_size=append(mod_files_size,p_rec.name)
                    endif
                endif
            endif
        endfor

        # summary
        if conf.summary

            sum=""
            on len(new_files)>0       do sum=sum+ " New       : {new_files}"
            on len(rem_files)>0       do sum=sum+ " Removed   : {rem_files}"
            on len(mod_files_time)>0  do sum=sum+ " Mod, Time : {mod_files_time}"
            on len(mod_files_size)>0  do sum=sum+ " Mod, Size : {mod_files_size}"

            if sum!=""
                sum="[#6]{=date_human()}    [#5]Directory -> {d}[#-]\n{sum}\n"
                println sum
            endif

        endif

        # take actions
        when conf.action
        is "copy"
            # new
            foreach f in new_files
                println "[COPY] NEW {f} to {=conf.destination}"
                on !copy(mkfn(d,f),mkfn(conf.destination,f)) do println ": error copying {f}"
            endfor
            # rem
            foreach f in rem_files
                if conf.mirror
                    println "[COPY] REM {f} from {=conf.destination} (mirror mode)"
                    if is_file(mkfn(conf.destination,f))
                        on !delete(mkfn(conf.destination,f)) do println ": error removing {f}"
                    endif
                endif
            endfor
            # mod time
            foreach f in mod_files_time
                println "[COPY] MODT {f} to {=conf.destination}"
                on !copy(mkfn(d,f),mkfn(conf.destination,f)) do println ": error copying {f}"
            endfor
            # mod size
            foreach f in mod_files_size
                println "[COPY] MODS {f} to {=conf.destination}"
                on !copy(mkfn(d,f),mkfn(conf.destination,f)) do println ": error copying {f}"
            endfor
        is "move"
            # new
            foreach f in new_files
                println "[MOVE] NEW {f} to {=conf.destination}"
                on !rename(mkfn(d,f),mkfn(conf.destination,f)) do println ": error moving {f}"
            endfor
            # rem
            foreach f in rem_files
                if conf.mirror
                    println "[MOVE] REM {f} from {=conf.destination} (mirror mode)"
                    on !delete(mkfn(conf.destination,f)) do println ": error removing {f}"
                endif
            endfor
            # mod time
            foreach f in mod_files_time
                println "[MOVE] MODT {f} to {=conf.destination}"
                on !rename(mkfn(d,f),mkfn(conf.destination,f)) do println ": error moving {f}"
            endfor
            # mod size
            foreach f in mod_files_size
                println "[MOVE] MODS {f} to {=conf.destination}"
                on !rename(mkfn(d,f),mkfn(conf.destination,f)) do println ": error moving {f}"
            endfor
        is "delete"
            # new
            foreach f in new_files
                println "[DELETE] NEW {f}"
                on !delete(mkfn(d,f)) do println ": error removing {f}"
            endfor
        is ""
        or
            error("bad action verb in watch configuration file",3)
        endwhen

    endif

    # modify prev and pass back
    conf.starting=false
    conf.prev=file_list
    return conf 
enddef


#
# MAIN
#

struct s_config
    configfile  string
    freq        float
    filter      string
    summary     bool
    dirs        []
    prev        []
    starting    bool
    action      string
    destination string
    mirror      bool
endstruct

# initialise config struct with some default values
init c s_config
c.starting      = true
c.freq          = 2.5
c.configfile    = "./watch.conf"
c.filter        = ".*"
c.summary       = true
c.prev          = []
c.action        = ""
c.destination   = ""
c.mirror        = false

# check for env vars
input ecf env CF 
on ecf!="" do c.configfile=ecf

# read in config file
foreach l in read_file(c.configfile)
    on get_value(l,"dir")!=""           do c.dirs=append(c.dirs,stripquotes(get_value(l,"dir")))
    on get_value(l,"action")!=""        do c.action=stripquotes(get_value(l,"action"))
    on get_value(l,"destination")!=""   do c.destination=stripquotes(get_value(l,"destination"))
    on get_value(l,"filter")!=""        do c.filter=stripquotes(get_value(l,"filter"))
    on get_value(l,"summary")!=""       do c.summary=bool(stripquotes(get_value(l,"summary")))
    on get_value(l,"mirror")!=""        do c.mirror=bool(stripquotes(get_value(l,"mirror")))
    f=get_value(l,"frequency")
    if f!=""
        if ! is_number(f)
            error("bad frequency ({f}) in config file",2)
        endif
        c.freq=float(f)
    endif
endfor

# main loop

trapInt="handlebreak(0)"
quit=false

while !quit

    # md="{=time_dow()} {=time_hours()}:{=time_minutes()}.{=time_seconds()}"
    # println "[watch] (freq:{=c.freq}) : {md}"

    foreach d in c.dirs
        c=check_dir(c,d)
    endfor

    # should change this delay to take into account the time taken by check_dir() above
    pause c.freq*1000

endwhile

exit 0


