#!/usr/bin/za

doc `
    not portable example for getting the process list. requires compatible procfs and sane defaults.

    this is pretty slow, as we are combing through every /proc/$pid for a variety of things.

`

struct process
    pid         int
    name        string
    state       string
    ppid        int
    priority    int
    starttime   int
    uid         string
    gid         string
endstruct

struct pid_lookup
    pid         int
    index       string
endstruct

# (even more) hacky sort, as there's no builtin sort by struct field
define fsort(m)
    s=""
    foreach q in m
        s+="{=q.pid} {=q.index}\n"
    endfor
    return fieldsort(s,1,"n")
end

define splitOnZero(s)
    return split(s,string(char(0)))
end

define ps(filter)
    on filter==nil do filter="^.*$"
    procs = ${ls -1 /proc/*/stat}.line_filter("/[0-9]+/")

    var args        map
    var virt_size   map
    var rss_size    map
    var pss_size    map
    var proc_list   map
    var proc        process

    foreach p in procs

        on !is_file(p) do continue
        ps = $in p      # @race: these files can go away
        cmd=ps.filter(`\(.*?\)`).tr("d","()")
        on !match(cmd,filter) do continue
        ps.replace("\(.*?\)","command").fields
        proc.pid      = F[1].int
        proc.state    = F[3]
        proc.ppid     = F[4].int
        proc.priority = F[18].int
        proc.starttime= F[22].int
        proc.name     = cmd
        args[proc.pid]= $in "/proc/{=proc.pid}/cmdline".splitOnZero
        proc_list[proc.pid] = proc

        smap_file="/proc/{=proc.pid}/smaps"
        virt_size[proc.pid] = $in smap_file.grep("^Size:").tr("s"," ").col(2," ").list_int.sum.int
        rss_size[proc.pid]  = $in smap_file.grep("^Rss:").tr("s"," ").col(2," ").list_int.sum.int
        pss_size[proc.pid]  = $in smap_file.grep("^Pss:").tr("s"," ").col(2," ").list_int.sum.int

    endfor

    var keys []pid_lookup
    var l pid_lookup
    foreach v in proc_list
        l.pid=v.pid
        l.index=v.name
        append_to(ref keys,l)
    endfor
    return proc_list,keys,args,virt_size,rss_size,pss_size
end

define short_size(d)
    # inbound value is in kb
    unit="K"
    if d>1024; d=d/1024f; unit="M"; endif
    if d>1024; d=d/1024f; unit="G"; endif
    on d!=0 do return d.int.string+unit
    return ""
end

#
# MAIN
#

# args
input filter optarg 1

# fetch process list and sort by pid
res,keys,arglists,virt_size,rss,pss=ps(filter)
fs=fsort(keys)

# display
title=format("\n[#bold][#ul]%-7s %-7s %2s %9s %9s %9s %16s %16s %4s %-"+string(term_w()-98)+"s[#-]",
                "PID","PPID","ST","VIRT","RSS","PSS","USER","GROUP","PRI","CMD"
)

println title
lines=0
foreach r in fs
    findpid=field(r,1)
    p=res[findpid]
    if can_read("/proc/{=p.pid}")
        s=stat("/proc/{=p.pid}")
        p.uid=s.Uid.string
        p.gid=s.Gid.string
        on username(p.uid.int)!="" do p.uid=username(p.uid.int)
        on groupname(p.gid.int)!="" do p.gid=groupname(p.gid.int)
    endif

    args=format("%v",arglists[p.pid])
    args=args.trim(0,"[]")
    l=args.len
    if l==0
        args+="[#1]["+p.name+"][#-]"
    else
        args=args[0:min([args.len,term_w()-99])]
        on args.len!=l do args+="[#2]â€¦[#-]"
    endif

    vsize = virt_size[p.pid]
    rsize = rss[p.pid]
    psize = pss[p.pid]

    vsize_string = vsize!=-1 ? short_size(vsize) : ""
    rsize_string = rsize!=-1 ? short_size(rsize) : ""
    psize_string = psize!=-1 ? short_size(psize) : ""

    println format("[#5][#bold]%-7d[#boff] %-7d [#2]%2s %9s %9s %9s [#6]%16s %16s [#7]%4d [#bold]%s[#-]",
            p.pid,p.ppid,p.state,
            vsize_string,rsize_string,psize_string,
            string(p.uid),string(p.gid),
            p.priority,args
    )

    lines++
    if lines>=term_h()-1
        println title
        lines=0
    endif
endfor



