#!/usr/bin/za

doc `
    todo:
    * swap bits out for more za idiomatic stuff where possible.
    * tidy
    * optimise some stuff
`

doc `

  A terrible conversion of lbForth.c

    just testing out the exec() lib call

    this is more or less a straight translation from c to za
    problem is, we don't have pointers...

    * pointers all converted to memory offsets.
    * added a few minor things, like backspace support
    * increased the base memory/stack sizes
    * it's going to be slow - nothing clever done to take
        advantage of za library/builtins and, of course, 
        it's an interpreter written in another interpreter.
    * lots of bugs:
        - initscript func defs not all built right (hence currently commented)
        - some oddities around keyboard input
        - console output hinky, needs some attention
        - i.e. it's pretty broken
    * it's not finished, was just taken this far as a test.
`


# Basic memory configuration
MEM_SIZE        =65536*4    # main memory size in bytes
STACK_SIZE      =192*4      # cells reserved for the stack
RSTACK_SIZE     =64         # cells reserved for the return stack
INPUT_LINE_SIZE =32         # bytes reserved for the WORD buffer

#########################################################################################

CELL_SIZE=1
DCELL_SIZE=2

# A few constants that describe the memory layout of this implementation
LATEST_POSITION = INPUT_LINE_SIZE
HERE_POSITION   = (LATEST_POSITION + CELL_SIZE)
BASE_POSITION   = (HERE_POSITION + CELL_SIZE)
STATE_POSITION  = (BASE_POSITION + CELL_SIZE)
STACK_POSITION  = (STATE_POSITION + CELL_SIZE)
RSTACK_POSITION = (STACK_POSITION + STACK_SIZE * CELL_SIZE)
HERE_START      = (RSTACK_POSITION + RSTACK_SIZE * CELL_SIZE)
MAX_BUILTIN_ID  = 73

# Flags and masks for the dictionary 
FLAG_IMMEDIATE  = 0x80
FLAG_HIDDEN     = 0x40
MASK_NAMELENGTH = 0x1F

# This is the main memory to be used by this Forth.
# There will be no malloc in this file.
var memory [MEM_SIZE]int

# [ Pointers to Forth variables stored inside the main memory array ]
# we don't have pointers, so these are offsets from memory[0]
var latest,here,sp,stack,rsp,rstack int

# misc state info
var base,state int

# A few helper variables for the compiler
var exitReq,errorFlag bool
var next,lastIp,quit_address,commandAddress,maxBuiltinAddress int

# The TIB, stored outside the main memory array for now
var lineBuffer[128] int
var charsInLineBuffer int 
var positionInLineBuffer int

var builtins[MAX_BUILTIN_ID] string
var btoname[MAX_BUILTIN_ID] string
var wordtofunc assoc


# A basic setup for defining builtins.
# func calls are stored as strings, then created as za functions
# for later execution.

define BUILTIN(id,name,za_name,flags,func)
    # println "Creating definition config : ",c_name
    setglob forth_{za_name}_id=id.int
    setglob forth_{za_name}_fname=name
    setglob forth_{za_name}_flags=flags.int
    setglob forth_{za_name}_func=func
end

define ADD_BUILTIN(za_name)
    id     = forth_{za_name}_id
    fname  = forth_{za_name}_fname
    flags  = forth_{za_name}_flags
    func   = forth_{za_name}_func
    println fg256(200),"ADD_BUILTIN : [{id},{fname},{flags}][#-]"
    addBuiltin(id,za_name,fname,flags,func)
end

define banner()
    println "\n[#6]Quarter[#-] - [#i1]the slowest Forth[#i0]\n"
    println "[#2] Use this at your own peril![#-]\n"
end

# This is our initialization script containing all the words we define in
#  Forth for convenience. Focus is on simplicity, not speed. Partly copied from
#  Jonesforth (see top of file).

initscript=`
    : CR 10 EMIT ;
    : BL 32 ;
    : SPACE BL EMIT ;
    : NEGATE 0 SWAP - ;
    : . . SPACE ;
    : ? @ . ;
    : TRUE 1 ;
    : FALSE 0 ;
    : DECIMAL 10 BASE ! ;
    : HEX 16 BASE ! ;
    : OCTAL 8 BASE ! ;
    : 2DUP OVER OVER ;
    : 2DROP DROP DROP ;
    : NIP SWAP DROP ;
    : 2NIP 2SWAP 2DROP ;
    : TUCK SWAP OVER ;
    : / /MOD NIP ;
    : MOD /MOD DROP ;
    : DNEGATE 0. 2SWAP D- ;
    : CELLS CELL * ;
    : ALLOT HERE @ + HERE ! ;
    : 0= 0 = ;
    : 0< 0 < ;
    : 0> 0 > ;
    : <> = 0= ;
    : <= > 0= ;
    : >= < 0= ;
    : 0<= 0 <= ;
    : 0>= 0 >= ;
    : 1+ 1 + ;
    : 1- 1 - ;
    : 2+ 2 + ;
    : 2- 2 - ;
    : 2/ 2 / ;
    : 2* 2 * ;
    : D2/ 2. D/ ;
    : +! DUP @ ROT + SWAP ! ;
    : [COMPILE] WORD FIND >CFA , ; IMMEDIATE
    : [CHAR] key ' LIT , , ; IMMEDIATE
    : RECURSE LATEST @ >CFA , ; IMMEDIATE
    : DOCOL 0 ;
    : CONSTANT CREATE DOCOL , ' LIT , , ' EXIT , ;
    : 2CONSTANT SWAP CREATE DOCOL , ' LIT , , ' LIT , , ' EXIT , ;
    : VARIABLE HERE @ CELL ALLOT CREATE DOCOL , ' LIT , , ' EXIT , ;
    : 2VARIABLE HERE @ 2 CELLS ALLOT CREATE DOCOL , ' LIT , , ' EXIT , ;
    : IF ' 0BRANCH , HERE @ 0 , ; IMMEDIATE
    : THEN DUP HERE @ SWAP - SWAP ! ; IMMEDIATE
    : ELSE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ; IMMEDIATE
    : BEGIN HERE @ ; IMMEDIATE
    : UNTIL ' 0BRANCH , HERE @ - , ; IMMEDIATE
    : AGAIN ' BRANCH , HERE @ - , ; IMMEDIATE
    : WHILE ' 0BRANCH , HERE @ 0 , ; IMMEDIATE
    : REPEAT ' BRANCH , SWAP HERE @ - , DUP HERE @ SWAP - SWAP ! ; IMMEDIATE
    : UNLESS ' 0= , [COMPILE] IF ; IMMEDIATE
    : DO HERE @ ' SWAP , ' >R , ' >R , ; IMMEDIATE
    : LOOP ' R> , ' R> , ' SWAP , ' 1+ , ' 2DUP , ' = , ' 0BRANCH , HERE @ - , ' 2DROP , ; IMMEDIATE
    : +LOOP ' R> , ' R> , ' SWAP , ' ROT , ' + , ' 2DUP , ' <= , ' 0BRANCH , HERE @ - , ' 2DROP , ; IMMEDIATE
    : SPACES DUP 0> IF 0 DO SPACE LOOP ELSE DROP THEN ;
    : I ' R@ , ; IMMEDIATE
    : ABS DUP 0< IF NEGATE THEN ;
    : DABS 2DUP 0. D< IF DNEGATE THEN ;
    : .DIGIT DUP 9 > IF 55 ELSE 48 THEN + EMIT ;
    : .SIGN DUP 0< IF 45 EMIT NEGATE THEN ;
    : .POS BASE @ /MOD ?DUP IF RECURSE THEN .DIGIT ;
    : . .SIGN DUP IF .POS ELSE .DIGIT THEN ;
    : COUNTPOS SWAP 1 + SWAP BASE @ / ?DUP IF RECURSE THEN ;
    : DIGITS DUP 0< IF 1 ELSE 0 THEN SWAP COUNTPOS ;
    : .R OVER DIGITS - SPACES . ;
    : .S DSP@ BEGIN DUP S0@ > WHILE DUP ? CELL - REPEAT DROP ;
    : TYPE 0 DO DUP C@ EMIT 1 + LOOP DROP ;
    : ALIGN BEGIN HERE @ CELL MOD WHILE 0 C, REPEAT ;
    : s" ' LITSTRING , HERE @ 0 , BEGIN KEY DUP 34 <> WHILE C, REPEAT DROP DUP HERE @ SWAP - CELL - SWAP ! ALIGN ; IMMEDIATE
    : ." [COMPILE] s" ' TYPE , ; IMMEDIATE
    : ( BEGIN KEY [CHAR] ) = UNTIL ; IMMEDIATE
    : COUNT DUP 1+ SWAP C@ ;
    : MIN 2DUP < IF DROP ELSE NIP THEN ;
    : MAX 2DUP > IF DROP ELSE NIP THEN ;
    : D0= OR 0= ;
    : DMIN 2OVER 2OVER D< IF 2DROP ELSE 2NIP THEN ;
    : DMAX 2OVER 2OVER D> IF 2DROP ELSE 2NIP THEN ;

`

################################################################################

define comma()
    push16(here)
    memWrite()
    setglob here = here + CELL_SIZE
end

define commaByte()
  push16(here)
  memWriteByte()
  setglob here = here + 1
end

################################################################################

# The primary data output function.
define putkey(c)
    print c.string
end

define putBackspace()
    print "[#CSI]1D [#CSI]1D"
    # putkey(27); putkey("[".asc); putkey(49); putkey(68)
    # putkey(32)
    # putkey(27); putkey("[".asc); putkey(49); putkey(68)
end


# The primary data input function.
define llkey()
    if initscript_pos<initscript_end_pos
        setglob initscript_pos++
        print "."
        return initscript[initscript_pos-1].asc
    endif
    on initialising do reprompt()
    setglob initialising=false
    c=keypress(0)
    print c.char
    return c
end

# Anything waiting in the keyboard buffer?
define keyWaiting()
    return positionInLineBuffer<charsInLineBuffer
end

define getkey()
    if keyWaiting()
        setglob positionInLineBuffer++
        return lineBuffer[positionInLineBuffer-1]
    endif
    setglob charsInLineBuffer = 0

    c=llkey()
    while c!=0
        add=true
        if c == 127
            add=false
            if charsInLineBuffer>0
                setglob charsInLineBuffer--
                setglob lineBuffer[charsInLineBuffer]=0
                putBackspace()
            endif
        endif
        if add
            on charsInLineBuffer == sizeof(lineBuffer) do break
            setglob lineBuffer[charsInLineBuffer] = c
            setglob charsInLineBuffer++
        endif
        on c==13 or c==10 do break
        if c==4
            setglob exitReq=true
            break
        endif
        c=llkey()
    endwhile 
    setglob positionInLineBuffer = 1
    return lineBuffer[0]
end


# The basic (data) stack operations

define memWriteByte()
    address = pop16()
    value = pop16()
    setglob memory[address] = value & 255
end

define memWrite()
    address = pop16()
    value = pop16()
    writeMem(address, value)
end

define pop16()
    if sp==1
        print "? (pop) Stack underflow\n"
        setglob errorFlag = true
        return 0
    endif
    setglob sp=sp-1
    return memory[stack+sp]
end

define tos()
    if sp==1
        print "[#2]? (tos) Stack underflow[#-]\n"
        setglob errorFlag = true
        return 0
    endif 
    return memory[stack+sp-1]
end

define push16(data)
    if sp >= STACK_SIZE
        print "? (push) Stack overflow\n"
        setglob errorFlag = true
        return
    endif
    setglob memory[stack+sp] = data
    setglob sp=sp+1
end

define pop32()
    tmpL = pop16()
    tmpH = pop16()
    return (tmpH<<16)+tmpL
end

define push32(data)
    # push high bytes then low
    tmpH=data & 0xFFFF0000
    tmpL=data & 0x0000FFFF
    push16(tmpH)
    push16(tmpL)
end

# The basic return stack operations
define rpop()
    if rsp == 0
        print "? (pop) RStack underflow\n"
        setglob errorFlag = true
        return 0
    endif
    setglob rsp--
    return memory[rstack+rsp]
end

define rpush(data)
    if rsp >= RSTACK_SIZE-1
        print "? (push) RStack overflow\n"
        setglob errorFlag = true
        return
    endif
    setglob memory[rstack+rsp] = data
    setglob rsp++
end


# Secure memory access
define readMem(address)
    if address > MEM_SIZE
        print "Internal error in readMem: Invalid address\n"
        setglob errorFlag = true
        return 0
    endif
    return memory[address]
end

define writeMem(address,value)
    if address > MEM_SIZE
        print "Internal error in writeMem: Invalid address\n"
        setglob errorFlag = true
        return
    endif
    setglob memory[address]=value
end

define stackPreview()
    pre=""
    for e = sp[:9] to 2 step -1
        pre=pre+memory[stack+e-1].string+" "
    endfor
    return pre
end

define reprompt()
    # on get_row()>=term_h() do print "\n"
    print "\n","ssz [{=sp-1}] | {=stackPreview()} {=linePrompt}"
end

# Reading a word into the input line buffer
define readWord()
    c=13

    while
        on not initialising and (c==13 or c==10) do reprompt()
        c=getkey()
        # handle whitespace input
        if c==4
            setglob exitReq=true
            break
        endif
        on c==32 do continue
        if c==13 or c==10
            continue
        endif
        # handle escaped input
        on c != 92 do break # backslash
        while c != 0
            c=getkey()
            on c==10 do break
        endwhile
    endwhile

    line=""
    length=0
    # handle word input
    while not (c in [0,4,10,13,32])
        on length>=(INPUT_LINE_SIZE - 1) do break
        line=line+char(c)
        length++
        c = getkey()
    endwhile

    return line

end

define writeStringToMemory(s,pos)
    l=s.len
    writeMem(pos,l)
    for e=1 to l
        c=s[e-1].asc
        writeMem(pos+e,c)
    endfor
end

define readStringFromMemory(pos)
    s=""
    length=memory[pos]
    for e=pos+1 to pos+length
        s+=char(memory[e])
    endfor
    return s,length
end

# Dictionary lookup
define findWord(address,length)

    name,_ = readStringFromMemory(address)
    ret = latest
    found=false

    while

        ret = readMem(ret)
        on ret==0 or errorFlag do break
    

        on (memory[ret+CELL_SIZE] & MASK_NAMELENGTH) != length do continue
        on (memory[ret+CELL_SIZE] & FLAG_HIDDEN) != 0          do continue

        found = true
        for i=1 to length
            ch=memory[ret+i+CELL_SIZE].char
            if $uc (memory[ret+i+CELL_SIZE].char) != $uc name[i-1]
                found = false
                break
            endif
        endfor

        on found do break

    endwhile

    on not found do return 0
    return ret
end

# Basic number parsing
define parseNumber(addr)

    w,length = readStringFromMemory(addr)
    negative = false
    isDouble = false

    on w ~ "-" do negative=true
    on w ~ "\." do isDouble=true

    on isDouble     do return w.float,false,isDouble
    on is_number(w) do return w.int,false,isDouble

    return 0,true,isDouble

end

# Builtin definitions

BUILTIN( 0, "RUNDOCOL",  "docol",           0,                `rpush(lastIp);setglob next = commandAddress + CELL_SIZE`)
BUILTIN( 1, "CELL",      "doCellSize",      0,                `push16(CELL_SIZE)`)
BUILTIN( 2, "@",         "memRead",         0,                `push16(readMem(pop16()))`)
BUILTIN( 3, "C@",        "memReadByte",     0,                `push16(memory[pop16()])`)
BUILTIN( 4, "KEY",       "gkey_proto",      0,                `getkey().push16`)
BUILTIN( 5, "EMIT",      "emit",            0,                `putkey(pop16() & 255)`)
BUILTIN( 6, "DROP",      "drop",            0,                `pop16()`)
BUILTIN( 7, "EXIT",      "doExit",          0,                `setglob next = rpop()`)
BUILTIN( 8, "BYE",       "bye",             0,                `setglob exitReq = true`)
BUILTIN( 9, "LATEST",    "doLatest",        0,                `push16(LATEST_POSITION)`)
BUILTIN(10, "HERE",      "doHere",          0,                `push16(HERE_POSITION)`)
BUILTIN(11, "BASE",      "doBase",          0,                `push16(BASE_POSITION)`)
BUILTIN(12, "STATE",     "doState",         0,                `push16(STATE_POSITION)`)
BUILTIN(13, "[",         "gotoInterpreter", FLAG_IMMEDIATE,   `setglob state = 0`)
BUILTIN(14, "]",         "gotoCompiler",    0,                `setglob state = 1`)
BUILTIN(15, "HIDE",      "hide",            0,                `pos=memory[latest+CELL_SIZE]; setglob memory[pos] = memory[pos] ^ FLAG_HIDDEN`)
BUILTIN(16, "R>",        "rtos",            0,                `rpop().push16`)
BUILTIN(17, ">R",        "stor",            0,                `pop16().rpush`)
BUILTIN(18, "KEY?",      "key_p",           0,                `keyWaiting().btoi.push16`)
BUILTIN(19, "BRANCH",    "branch",          0,                `setglob next += readMem(next)`)
BUILTIN(20, "0BRANCH",   "zbranch",         0,                `setglob next += ?? pop16() CELL_SIZE:readMem(next)`)
BUILTIN(21, "IMMEDIATE", "toggleImmediate", FLAG_IMMEDIATE,   `pos=memory[latest+CELL_SIZE];setglob memory[pos] = memory[pos] ^ FLAG_IMMEDIATE`)
BUILTIN(22, "FREE",      "doFree",          0,                `push16(MEM_SIZE-here)`)
BUILTIN(23, "S0@",       "s0_r",            0,                `push16(STACK_POSITION+CELL_SIZE)`)
BUILTIN(24, "DSP@",      "dsp_r",           0,                `push16(STACK_POSITION+sp*CELL_SIZE)`)
BUILTIN(25, "NOT",       "fnot",            0,                `(!itob(pop16())).btoi.push16()`)
BUILTIN(26, "DUP",       "dup",             0,                `push16(tos())`)
BUILTIN(27, "!", "memWrite", 0,nil)
BUILTIN(28, "C!", "memWriteByte", 0,nil)

BUILTIN(29, "SWAP", "swap", 0,
` a = pop16()
  b = pop16()
  a.push16
  b.push16
`)

BUILTIN(30, "OVER", "over", 0,
` a = pop16()
  b = tos()
  a.push16
  b.push16
`)

BUILTIN(31, ",", "comma", 0,nil)
BUILTIN(32, "C,", "commaByte", 0,nil)

BUILTIN(33, "WORD", "word", 0,
`
  word = readWord()
  writeStringToMemory(word,1)
  push16(1)
  push16(word.len)
`)

BUILTIN(34, "FIND", "find", 0,
` length=pop16()
  address=pop16()
  fw=findWord(address,length)
  fw.push16
`)

define getcfa(address)
    length = (memory[address + CELL_SIZE] & MASK_NAMELENGTH) + 1
    while (length & (CELL_SIZE-1)) != 0
        length++
    endwhile
    return address + CELL_SIZE + length
end

BUILTIN(35, ">CFA", "cfa", 0,
` address = pop16()
  ret = getcfa(address)
  if ret<maxBuiltinAddress
    readMem(ret).push16
  else
    push16(ret)
  endif
`)

BUILTIN(36, "NUMBER", "number", 0,
` length = pop16()
  address =pop16()
  num,notRead,isDouble=parseNumber(address)
  if isDouble
      push32(num)
  else
      push16(num)
  endif
  push16(notRead)
`)

BUILTIN(37, "LIT", "lit", 0,
` readMem(next).push16
  setglob next += CELL_SIZE
`)

define getWord(addr)
    w=""
    for e=1 to memory[addr+2]&MASK_NAMELENGTH
        w=w+char(memory[addr+2+e])
    endfor
    return w
end

# Outer and inner interpreter
BUILTIN(38, "QUIT", "quit", 0,
`
    while not exitReq

        setglob next = quit_address
        setglob lastIp = next
        setglob errorFlag = false

        word()
        find()
        on not keyWaiting() and initscript_pos==initscript_end_pos do print "\n"

        address = pop16()
        if address!=0
            immediate = memory[address+CELL_SIZE] & FLAG_IMMEDIATE
            setglob commandAddress = getcfa(address)
            command = readMem(commandAddress)
            if state!=0 and immediate==0
                if command < MAX_BUILTIN_ID and command != forth_docol_id
                    push16(command)
                else
                    push16(commandAddress)
                endif
                comma()
            else
                while not errorFlag and not exitReq
                    on command==forth_quit_id do break
                    when
                    has command < MAX_BUILTIN_ID
                        exec(btoname[command]+"()")
                    or
                        setglob lastIp = next
                        setglob next = command
                    endwhen

                    setglob commandAddress = next
                    command = readMem(commandAddress)
                    setglob next = next + CELL_SIZE
                endwhile
            endif
        else
            number,notRead,isDouble=parseNumber(1)
            if notRead and number!=0
                print "Unknown word: (",number,") "
                for i=0 to memory[0]
                    putkey(memory[i+1])
                endfor
                putkey(10)

                setglob rsp=1 
                setglob sp=rsp
                continue
            else 
                if state!=0
                    tmpH=number & 0xFFFFFFFF00000000
                    tmpL=number & 0x00000000FFFFFFFF
                    forth_lit_id.push16
                    comma()

                    if isDouble
                        tmpH.push16
                        comma()
                        forth_lit_id.push16
                        comma()
                        tmpL.push16
                        comma()
                    else
                        number.push16
                        comma()
                    endif
                else
                    if isDouble
                        number.push32
                    else
                        number.push16
                    endif
                endif 
            endif
        endif

        if errorFlag
            setglob rsp=1
            setglob sp=rsp
        else
            on keyWaiting() and not initialising do print " OK\n"
        endif

    endwhile

`)
            # initscript_pos==initscript_end_pos do print " OK\n"


BUILTIN(39, "+", "plus", 0,
`
    n1 = pop16()
    n2 = pop16()
    push16(n1+n2)
`)

BUILTIN(40, "-", "minus", 0,
`
    n1 = pop16()
    n2 = pop16()
    push16(n2 - n1)
`)

BUILTIN(41, "*", "mul", 0,
`
    n1 = pop16()
    n2 = pop16()
    push16(n1 * n2)
`)

BUILTIN(42, "/MOD", "divmod", 0,
`
    n1 = pop16()
    n2 = pop16()
    push16(n2 % n1)
    push16(n2 / n1)
`)

BUILTIN(43, "ROT", "rot", 0,
`
    a = pop16()
    b = pop16()
    c = pop16()
    push16(b)
    push16(a)
    push16(c)
`)

BUILTIN(44, "CREATE", "doCreate", 0,
`   word()
    length = pop16() & 255
    address = pop16()
    name,l = readStringFromMemory(address)
    createWord(name, length, 0)
`)

BUILTIN(45, ":", "colon", 0,
`   doCreate()
    push16(forth_docol_id)
    comma()
    hide()
    setglob state = 1
`)

BUILTIN(46, ";", "semicolon", FLAG_IMMEDIATE,
`
    push16(forth_doExit_id)
    comma()
    hide()
    setglob state = 0
`)

BUILTIN(47, "R@", "rget", 0,
`
    tmp = rpop()
    tmp.rpush
    tmp.push16
`)

BUILTIN(48, "J", "doJ", 0,
`
    tmp1 = rpop()
    tmp2 = rpop()
    tmp3 = rpop()
    rpush(tmp3)
    rpush(tmp2)
    rpush(tmp1)
    push16(tmp3)
`)

BUILTIN(49, "'", "tick", FLAG_IMMEDIATE,
`
    word()
    find()
    cfa()

    if state!=0
        push16(forth_lit_id)
        comma()
        comma()
    endif 
`)

BUILTIN(50, "=", "equals", 0,
`
    a1 = pop16()
    a2 = pop16()
    push16(?? a2==a1 1:0)
`)

BUILTIN(51, "<", "smaller", 0,
`
    a1 = pop16()
    a2 = pop16()
    push16(?? a2<a1 1:0)
`)

BUILTIN(52, ">", "larger", 0,
`
    a1 = pop16()
    a2 = pop16()
    push16(?? a2>a1 1:0)
`)

BUILTIN(53, "AND", "doAnd", 0,
`
    a1 = pop16()
    a2 = pop16()
    push16(a2 & a1)
`)

BUILTIN(54, "OR", "doOr", 0,
`
    a1 = pop16()
    a2 = pop16()
    push16(a2 | a1)
`)

BUILTIN(55, "?DUP", "p_dup", 0,
`
    a = tos()
    on a!=0 do push16(a)
`)

BUILTIN(56, "LITSTRING", "litstring", 0,
`
    length = readMem(next)
    setglob next += CELL_SIZE
    push16(next)
    push16(length)
    setglob next += length
    while next & (CELL_SIZE-1)
        setglob next=next+1
    endwhile
`)

BUILTIN(57, "XOR", "xor", 0,
`
    a = pop16()
    b = pop16()
    push16(a ^ b)
`)

BUILTIN(58, "*/", "timesDivide", 0,
`
    n3 = pop16()
    n2 = pop16()
    n1 = pop16()
    r = (n1 * n2) / n3
    push16(r)
    if r != r
        print "Arithmetic overflow\n"
        setglob errorFlag = true
    endif
`)

BUILTIN(59, "*/MOD", "timesDivideMod", 0,
`
    n3 = pop16()
    n2 = pop16()
    n1 = pop16()
    r = (n1 * n2) / n3
    m = (n1 * n2) % n3
    push16(m)
    push16(r)
    if r != r
        print "Arithmetic overflow\n"
        setglob errorFlag = true
    endif
`)

BUILTIN(60, "D=", "dequals", 0,
`
    a1 = pop32()
    a2 = pop32()
    push16(?? a2==a1 1:0)
`)

BUILTIN(61, "D<", "dsmaller", 0,
`
    a1 = pop32()
    a2 = pop32()
    push16(?? a2<a1 1:0)
`)

BUILTIN(62, "D>", "dlarger", 0,
`
    a1 = pop32()
    a2 = pop32()
    push16(?? a2>a1 1:0)
`)

BUILTIN(63, "DU<", "dusmaller", 0,
`
    a1 = pop32()
    a2 = pop32()
    push16(?? a2<a1 1:0)
`)

BUILTIN(64, "D+", "dplus", 0,
`
    n1 = pop32()
    n2 = pop32()
    push32(n1 + n2)
`)

BUILTIN(65, "D-", "dminus", 0,
`
    n1 = pop32()
    n2 = pop32()
    push32(n2 - n1)
`)

BUILTIN(66, "D*", "dmul", 0,
`
    n1 = pop32()
    n2 = pop32()
    push32(n1 * n2)
`)

BUILTIN(67, "D/", "ddiv", 0,
`
    n1 = pop32()
    n2 = pop32()
    push32(n2 / n1)
`)

BUILTIN(68, "2SWAP", "dswap", 0,
`
    a = pop32()
    b = pop32()
    push32(a)
    push32(b)
`)

BUILTIN(69, "2OVER", "dover", 0,
`
    a = pop32()
    b = pop32()
    push32(b)
    push32(a)
    push32(b)
`)

BUILTIN(70, "2ROT", "drot", 0,
`
    a = pop32()
    b = pop32()
    c = pop32()
    push32(b)
    push32(a)
    push32(c)
`)

BUILTIN(71, "WORDS", "wordlist", 0,
`
    ret = latest
    while
        ret = readMem(ret)
        on ret==0 or errorFlag do break
        length=memory[ret+CELL_SIZE]
        on (memory[ret+CELL_SIZE] & MASK_NAMELENGTH) != length do continue
        on (memory[ret+CELL_SIZE] & FLAG_HIDDEN) != 0          do continue
        for i=1 to length
            print $uc (memory[ret+i+CELL_SIZE].char)
        endfor
        print " "
    endwhile
    print
`)

define showdeflist()
    ret = latest
    while
        ret = readMem(ret)
        on ret==0 or errorFlag do break
        length=memory[ret+CELL_SIZE]
        on (memory[ret+CELL_SIZE] & MASK_NAMELENGTH) != length do continue
        on (memory[ret+CELL_SIZE] & FLAG_HIDDEN) != 0          do continue

        ns=""
        for i=1 to length
            c=$uc (memory[ret+i+CELL_SIZE].char)
            ns=ns+c
            print c
        endfor
        if wordtofunc[ns]!=nil
            showdef "{=wordtofunc[ns]}"
        else
            print "\n : USER WORD\n"
        endif
        print "\n"
    endwhile
    print
end

BUILTIN(72, "DEFS", "deflist", 0,
`   showdeflist()
`)


#
# Loose ends
#

# Create a word in the dictionary
define createWord(name,length,flags)
    nameOffset=0
    newLatest = here
    push16(latest)
    comma()
    push16(length|flags)
    commaByte()
    while nameOffset<length
        push16(asc(name[nameOffset]))
        commaByte()
        nameOffset++
    endwhile
    while (here & (CELL_SIZE-1)) != 0
        push16(0)
        commaByte()
    endwhile
    setglob latest = newLatest
end

# Add a builtin to the dictionary
define addBuiltin(code,za_name,fname,flags,f)

    on errorFlag do return

    if code >= MAX_BUILTIN_ID
        print "Error adding builtin "
        print fname
        print ": Out of builtin IDs\n"
        setglob errorFlag = true
        return
    endif

    # skip code 0 check as default value is 0
    if code!=0 and builtins[code] != ""
        print "Error adding builtin "
        print fname
        print ": ID [{code}] given twice\n"
        setglob errorFlag = true
        return
    endif

    if f==nil
        setglob wordtofunc[fname] = za_name
        setglob btoname[code]  = za_name
        println "  aB - no func - {code},{fname}"
    else
        if fname=="" or f==""
            println "Empty name or func in addBuiltin()"
        else
            if builtins[code]!=""
                println "[#5]BUILTIN {code} already defined!\nCannot add {za_name}.[#-]"
            else
                setglob wordtofunc[fname] = za_name
                setglob btoname[code]  = za_name
                setglob builtins[code] = f
                defcmd="\ndefine {za_name}()\n{f}\nend\n"
                defcmd.exec
            endif
        endif
    endif

    createWord(fname, fname.len, flags)
    push16(code)
    comma()
    push16(forth_doExit_id)
    comma()

end


#
# Program setup and jump to outer interpreter
#

initialising=true

errorFlag = false

if DCELL_SIZE != 2*CELL_SIZE
    print "Configuration error: DCELL_SIZE != 2*CELL_SIZE\n"
    return 1
endif

stack = STACK_POSITION + CELL_SIZE
rstack = RSTACK_POSITION + CELL_SIZE

sp = 1
rsp = 1
state = 0
base = 10
latest = 0
here = HERE_START

ADD_BUILTIN("memWrite")
ADD_BUILTIN("comma")
ADD_BUILTIN("memReadByte")
ADD_BUILTIN("memWriteByte")
ADD_BUILTIN("commaByte")
ADD_BUILTIN("memRead")
ADD_BUILTIN("docol")
ADD_BUILTIN("doCellSize")
ADD_BUILTIN("gkey_proto")
ADD_BUILTIN("emit")
ADD_BUILTIN("swap")
ADD_BUILTIN("dup")
ADD_BUILTIN("drop")
ADD_BUILTIN("over")
ADD_BUILTIN("word")
ADD_BUILTIN("find")
ADD_BUILTIN("cfa")
ADD_BUILTIN("doExit")
ADD_BUILTIN("quit")
quit_address = getcfa(latest)
ADD_BUILTIN("number")
ADD_BUILTIN("bye")
ADD_BUILTIN("doLatest")
ADD_BUILTIN("doHere")
ADD_BUILTIN("doBase")
ADD_BUILTIN("doState")
ADD_BUILTIN("plus")
ADD_BUILTIN("minus")
ADD_BUILTIN("mul")
ADD_BUILTIN("divmod")
ADD_BUILTIN("rot")
ADD_BUILTIN("gotoInterpreter")
ADD_BUILTIN("gotoCompiler")
ADD_BUILTIN("doCreate")
ADD_BUILTIN("hide")
ADD_BUILTIN("lit")
ADD_BUILTIN("colon")
ADD_BUILTIN("semicolon")
ADD_BUILTIN("rtos")
ADD_BUILTIN("stor")
ADD_BUILTIN("rget")
ADD_BUILTIN("doJ")
ADD_BUILTIN("tick")
ADD_BUILTIN("key_p")
ADD_BUILTIN("equals")
ADD_BUILTIN("smaller")
ADD_BUILTIN("larger")
ADD_BUILTIN("doAnd")
ADD_BUILTIN("doOr")
ADD_BUILTIN("branch")
ADD_BUILTIN("zbranch")
ADD_BUILTIN("toggleImmediate")
ADD_BUILTIN("doFree")
ADD_BUILTIN("p_dup")
ADD_BUILTIN("s0_r")
ADD_BUILTIN("dsp_r")
ADD_BUILTIN("litstring")
ADD_BUILTIN("fnot")
ADD_BUILTIN("xor")
ADD_BUILTIN("timesDivide")
ADD_BUILTIN("timesDivideMod")
ADD_BUILTIN("dequals")
ADD_BUILTIN("dsmaller")
ADD_BUILTIN("dlarger")
ADD_BUILTIN("dusmaller")
ADD_BUILTIN("dplus")
ADD_BUILTIN("dminus")
ADD_BUILTIN("dmul")
ADD_BUILTIN("ddiv")
ADD_BUILTIN("dswap")
ADD_BUILTIN("dover")
ADD_BUILTIN("drot")
ADD_BUILTIN("wordlist")
ADD_BUILTIN("deflist")

maxBuiltinAddress = here - 1

on errorFlag do return 1

initscript_pos = 0
initscript_end_pos=len(initscript)-1
linePrompt="> "
banner()
quit()
print
return 0


