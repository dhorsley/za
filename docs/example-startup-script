#!/usr/bin/za

doc `

    EXAMPLE STARTUP RC FILE

    copy this to $HOME/.zarc to use it.

`

# supporting functions

def unicode(a,b)
    return format("%c",as_int((a << 8) + b))
end

def form_logo()
    s=bg256(0x10)+unicode(0xf8,0xff)+" "+fg256(0x10)
    case release_id()
    contains "^(ubuntu|debian)$"
        s=bg256(0xd6)+"[#0] U "+fg256(0xd6)
    is "arch"
        s=bg256(0x1d)+"[#7] A "+fg256(0x1d)
    is "popos"
        s=bg256(0x4a)+"[#6] P "+fg256(0x4a)
    is "redhat"
        s=bg256(0xa0)+"[#7] R "+fg256(0xa0)
    endcase
    return s+bg256(0x12)
end

def form_time()
    return " %02d:%02d ".format(time_hours(),time_minutes())
end

def form_git()

    @inside_git=${git rev-parse --is-inside-work-tree 2>/dev/null}=="true" ? true:false

    if inside_git and (sysvar("@lastcmd") ~ "git" or cwd()!=last_git_path)
        @gs={git status}
        @gtl=${git rev-parse --show-toplevel}
        @last_git_path=cwd()
    endif

    if inside_git

        gs_text=gs.out.split("\n")

        _=fields(gs_text[0])
        if NF>0
            branch=F[NF]
        else
            branch=""
        endif

        unstaged=gs.out.grep("^Changes")

        _=fields(gs_text[1])
        if NF>5
            str_status=F[4:7].join
            status="[#2]✕[#0]"
            on unstaged.len==0 and str_status=="uptodate" do status="[#4]✓[#0]"
            return bg256(0xe2) + fg256(0x11) + " ({branch} {status}) " + bg256(0) + fg256(0xe2)
        endif

    endif
    return ""
end

def form_end_prompt()
    root=has_root()?"[#bold][#b2][#7] # [##]":""
    if last_cmd_status == 0
        return root+"[#bold][#4] ➜ "
    else
        return root+"[#bred] ✗ "
    endif
end

def form_dir()
    if inside_git
        path="…/"+cwd().replace(($pp gtl)+"/","")
    else
        path=cwd()
    endif
    return " "+path+" "
end

def form_aws()
    s=""
    foreach e in envlist
        if awsenv ~ key_e
            s=bg256(e.bg)+endcap+"[#{=e.fg}]"+" {=e.label} "+fg256(e.bg)
            break
        endif
    endfor
    if s==""
        if awsenv ~ "^.+$"
            s=bg256(0x00)+endcap+"[#7]"+" aws:other:{awsenv} "+fg256(0x00)
        else
            s=endcap
        endif
    endif
    return s
end

def form_prompt()
    @last_cmd_status=last()
    cached_fg=form_git()
    return (
        form_logo() + bg256(0x1b) + endcap +
        "[#6]"+form_dir() + bg256(0xe2) + fg256(0x1b) +
        form_aws() + bg256(0xe2) + endcap +
        cached_fg + endcap + "[#-][##]" + form_end_prompt() + "[#-][##]"
    )
end

def has_root()
    sudo=get_env("SUDO_USER")
    return sudo!="" or user()=="root"
end

# run cmd in parent shell without capturing channels
# this will not capture the error code correctly.
def nocap(cmd)
    capmem=sysvar("@commandCapture")
    comem=!sysvar("@runInParent")
    capture_shell(false)
    coproc(false)
    z={{cmd}}
    capture_shell(capmem)
    coproc(comem)
    return z
end

define humansize(i)
    i=i.as_float
    unit="B"
    mb=1024*1024
    gb=mb*1024
    if i>=gb; unit="GB"; i=as_float(i/gb); endif
    if i>=mb; unit="MB"; i=as_float(i/mb); endif
    if i>=1024; unit="KB"; i=as_float(i/1024); endif
    return format("%.1f %s",i,unit)
end

struct environment
    bg    int
    fg    int
    label string
endstruct


# set prompt
awsenv=get_env("AWS_DEFAULT_PROFILE") or get_env("AWS_PROFILE")

var envlist map
envlist["(?:os)?test"]    = environment(0x46,7,"aws:Test")
envlist["(?:os)?stage"]   = environment(0xa6,7,"aws:Stage")
envlist["(?:os)?live"]    = environment(0xa0,7,"aws:Live")
envlist["^$"]           = environment(0x11,7,"no-aws")

inside_git=false
last_cmd_status=0
last_git_path=""
endcap="▙"
gs={git status}
gtl=${git rev-parse --show-toplevel}
# right-hand side of prompt assignment is re-evaluated
# before each input prompt is presented.
prompt=(form_prompt())

# default banner
c=cpu_info()
amem=format("%.3f",mem_info().available.as_float/1024/1024/1024)
tmem=format("%.3f",mem_info().total.as_float/1024/1024/1024)
aswap=format("%.3f",mem_info().SwapFree.as_float/1024/1024/1024)
tswap=format("%.3f",mem_info().SwapTotal.as_float/1024/1024/1024)

banner=[]
_=append_to(ref banner,"[#1]···························│····················································")
_=append_to(ref banner,"[#1]··██████████···············│····················································")
_=append_to(ref banner,"[#1]··█░░░░░░███···············│···"+pad("      [#2]OS[#-]: {=release_name()} ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]·······███░····██████······│···"+pad("  [#2]Memory[#-]: {amem}/{tmem} GB ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]······███·····░░░░░███·····│···"+pad("    [#2]Swap[#-]: {aswap}/{tswap} GB ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]·····███·······███████·····│···"+pad("   [#2]Model[#-]: {=c.model} ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]···████·····█·███░░███·····│···"+pad("   [#2]Cores[#-]: {=c.cores} ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]··███████████░░████████····│···"+pad(" [#2]Threads[#-]: {=c.threads} ",-1,47)+"[#1]··")
_=append_to(ref banner,"[#1]·░░░░░░░░░░░··░░░░░░░░·····│····················································")
_=append_to(ref banner,"[#1]···························│····················································")

# show banner
p=banner.join("\n")
println "\n[#5]{p}[#-]"
help

unset banner,p


# enum helpers
enum s3sum ( okay=0, warn, file, sum )

# enable command fallback
_=permit("cmdfallback",true)

# set up aliases/macros
opt_icon="--icons=always"
macro +ls(path)     `at term_h(),1;ezapath="$path" or "."; "eza {opt_icon} {ezapath}".nocap.out`
macro +la(path)     `at term_h(),1;ezapath="$path" or "."; "eza -a {opt_icon} {ezapath}".nocap.out`
macro +df           `df -h`
macro +free         `free -m`
macro +b            `bat -f`
macro +ml           `macro list`
macro +v(path)      `"nvim $path".nocap.code`
macro +wget         `wget -c`
macro +cdl(dirname) `_=cd("$dirname"); "eza {opt_icon}".nocap.out`

macro +nic          `net_interfaces_detailed().table(map(
                        .colours map(.header "[#2]",.data "[#6]"),
                        .border_style "unicode",
                        .column_order ["index","up","name","hardware","mtu"].list_string,
                        .show_only_ordered true
                        ))`

macro +disk         `
                    unset data
                    data=disk_usage() ?> \`#.size>0 and #.path != "tmpfs"\`
                    foreach d in data
                        d.usage_percent=format("%.2f",d.usage_percent).as_float
                        d.used=humansize(d.used)
                        d.size=humansize(d.size)
                        d.available=humansize(d.available)
                    endfor
                    println data.table(
                        map(
                            .colours map(.header "[#2]",.data "[#6]"),
                            .border_style "unicode",
                            .align map(.size "right", .usage_percent "right", .used "right",.available "right"),
                            .column_order ["path","mounted_path","size","usage_percent","used","available"]
                        )
                    )`

macro +cpu          `
                    unset data
                    var data []
                    foreach c in cpu_info().Usage.cores
                        c.core=key_c
                        _=append_to(ref data,c)
                    endfor
                    println data.table(map(.colours map(.header "[#2]",.data "[#6]"),.border_style "unicode"))`

macro  +w `${w} . lines("1:") . table ( map(.has_headers true, .colours map(.header "[#2]",.data "[#6]"),.border_style "unicode" ) )`

macro +p(prof,cluster) `
    | export AWS_PROFILE="$prof"
    | kubectl config use-context $cluster
`

macro +ask(query,ask_rv) `
    url="https://api.cerebras.ai/v1/chat/completions"
    model="llama-3.3-70b"
    maxtokens=1000
    data=\`{
            "model":"{model}",
            "stream":false,
            "max_tokens":{maxtokens},
            "temperature":0.2,
            "top_p":1,
            "messages":[{"role":"system","content":"$query"}]
        }\`
    headers=map(
            .Authorization "Bearer "+get_env("ZA_AI_TOKEN"),
            .Content-Type "application/json"
    )
    result=web_raw_send("POST",url,headers,data)
    if result[2]==200
        parsed=json_decode(result[0])
        value=parsed.choices[0].message.content.md2ansi
        if "$ask_rv" == ""
            println value.wrap_text
        else
            $ask_rv = value
        endif
        unset value
    else
        println "Invalid response from AI endpoint."
    endif
    unset data,headers
`

