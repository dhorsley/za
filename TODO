

BUGS
----

lots, i'm sure.

    * (MOSTLY RESOLVED? to confirm) piping za | za has issues.

        - for example:

            za -c eg/ps "d$" | za -r -e 'on NF>2 do on F[3]=="S" do println _line'

        ... with the example ps script into an awk-like one liner.

        - presumably, stdin is getting thwacked in parallel. not sure what to do about it yet.
        - also, probably relatedly, execution may stop, waiting for a newline, at start of pipe input.
        - the problems go away when using a temporary file instead of a pipe to pass the za output->za input

        - (PARTIAL RESOLUTION)
          Console input and output, in Linux Za, is mainly underpinned by the Term package.
          This requires setting a device to use (/dev/tty in our case) and tracking variables for the row,col position.
          That tracking is handled by GetCursorPos() which interprets the ansi console sequence \033[6n
          via the term package. We don't do this very often as it's a costly call.
          However, during startup we do! It just needed shuffling beyond conflicting reads of os.Stdin to the point
          where we know whether input will be from console, file or pipe and have read those in.

    * possible bug... eg/ps requires coproc(false) when piped out. 
        - maybe related to above issue, but may be something else. subshell stdin/out/err manipulation
            could be interfering where it shouldn't.

        - not fixed yet, but added support in -> (map) operator so dir() could be used instead of ${ls -1} in eg/ps.

        - (UPDATE) it's something else :) resolution of piping bug didn't affect it. 
            - with the original ${ls -1}.grep() line back in place it still blows up without the za -S option.


TODO
----

    * process and/or job control support (TODO maybe?)
        - only currently have a few read-only calls for process IDs.
        - we should really support the following in some way:
            bg/fg/job/detach
            pidof/kill/ps
            daemonise (an async func call) without creating an event loop by hand.
            stream redirection and channel creation (maybe)
        - some of these are important enough facilities for a shell (pidof/kill/ps), but
          not sure i care enough about the job system beyond allow the supporting commands through
          unhindered to the coproc shell. job control would be important if we were primarily a shell,
          however, we aren't and the intention was always to supervise an existing shell.
            - if we end up moving more in that direction, then we should better support job control
              with first-class facilities.
        - not even convinced that pidof/kill/ps support are worthwhile either...
            - the chances are you are going to have to fetch from procfs files in some way, at which
              point, you may as well just have used the external commands in the bash co-process.
              - even tools like kubernetes do this. (harvesting /proc/).
            - we could do something similar for pidof as a test, but ps is already a pretty good tool.
            - kill is easy enough, assuming we own the process by exposing syscall.Kill() as a library call.

        - when done, we should maybe tie in &{...} to the job support.

            - currently &{...} *will* launch shell snippets inside an async func
                in Za, but they still bottleneck on the child process as that *has* to 
                be a synchronous thing to avoid interleaving. 
                - with -S option [coproc(false)] commands are run in separate processes depending 
                on env, which isn't much of an improvement as you lose other facilities in doing that.
                - instead, we should maybe be making a "{ ..code.. } &"  on coproc(true) calls,
                   in order to create a background job? 
                - doing that, of course, creates issues with exec()'ed coproc(false) calls and
                   potential issues on windows/other os/other shells than bash. 
                   - not too worried about this, i don't mind special casing a few major shells in linux.

            - if background processing is currently needed, then adding the & manually is possible.
                - i.e. {find /usr &} would work fine, for coproc(true) calls, you just don't get a
                  separate output capture as it interleaves.
                  - to be honest, i don't really see that as a problem as background processes should not
                    be reading from/writing to the console if well designed.
                  - you can also redirect to file i.e. {find /usr >filename &} as usual.


LATER / UNDECIDED
-----------------

    * revise source for generics support (go 1.18):
        - done. it doesn't look like there are a lot of places that generics would help us in terms
            of the primary functionality of the code. there are a few places around the standard lib
            it would help and a few other smaller parts of base functionality that could be converted
            but not as much as i'd hoped for! 
        - will pick away at these periodically.

    * add a hex_string=s3sum(filename_string[,blocksize_int]) call?
        - need to convert s3checksum C source to Go.
        - would be used to compare against an S3 header ETAG field to verify 
            either single or multi-part downloads
        - may need to do something to auto-detect block size based on size of first
            block when multi-part formulated and block size not provided as param?
        - would assume a default blocksize of 8192*1024 if not provided, but needed.
            
    * user and group builtins for linux?
        - i don't think this is necessary, especially as it would be so different between OS.
        - however, it makes scripting the stuff easier for a user by far if we support with builtins.
        - not doing this one yet, but still a possibility.

    * an actual type system:
        - something minimal, that doesn't get in the way of the interpreter
        - aligns with generics
        - retains what little speed we have
        - simplifies all the switch blocks we have hanging around
        - releases us from special casing all the stdlib-used types like dirent, big.*, etc
    
      Status: under consideration. depends on how much of the heavy lifting generics can do.


    * better namespacing?
        - ... and explicit embedding of structs as struct fields without using the 'any' type.
        - could also properly handle sane prefixing of stdlib funcs too.
      
      Status: unlikely to proceed. this is quite out of scope for the requirements. however, it may
                not be difficult to add. would probably need to add another identifier sub-type for
                namespace tokens. (as was done for constants).


    * handle multi-dimensional arrays better (as lvalues)

      Status: need to rework doAssign function to reduce its bulk first and handle lvalues better, 
                or push all of the work back into the evaluator for lvalues. that would probably be
                for the best, but i just can't bring myself to rework it for the limited benefits.
                this one is a maybe.


    * remaining issues post bind_int() changes:
        - race cond on ident write (vset): see ~/ttest
            - mainly to do with the time between reading a value and performing 
                doAssign() to update it in wrappedEval() function.
            - we can't lock the read+write as the read may invoke further 
                function calls recursively calling back through wrappedEval().
        - this is to be expected. you can't protect shared globals during fast
            switches without agressive locking.
        - we have a little protection around some operations, but it breaks down
            at high speeds. the protection is more for the implementation internals.

      Status: don't think i'll be doing much about this, except:
                - advising avoiding using shared memory at speed
                - maybe add some locking capability at the user level
                - advising to make changes to shared state sporadically in batches.
            it's a lot of work to fix this for a toy language.

    * add big.Rat?

      Status: very little work actually needed to do this, it's just more of the same as was done
                for big floats and ints. however, it is even more special casing without a driving
                requirement. if i decide against proper types (see above) then maybe will add this
                as already done for other bigs. not high on the priority list though.


    * do something about the mess that is lib-list.go

      Status: again, this depends on generics adoption. it would seem to be the only sane way to 
                reduce the mess.


    * ultimately, change interactive mode to use readline or similar with better utf-8 support
        (because I'm not likely to make many more changes to the in-built line editor):
        
        - some escaped chars (e.g. \") screw with the nesting check in interactive mode.
        - plenty of utf-8/extended char set keys still not working in interactive mode.
            - e.g. · µ n ”“ ¢ «» and similar.
        - cursor movement over utf8 chars in input (and utf8 char deletes) problematic.
        - update: this just hasn't proven to be much of an issue yet. it is certainly an inconvenience,
            but it is staying at the bottom of the change list indefinitely.

      Status: no plans to implement.


