

1.0.12  bug fixes , library return value review, 

    * no new functionality!!!
    * more example code in library docs (pulldoc gen)
    * remove deprecated features and options (startup options, dead code, unused funcs)

1.0.11  fixes and evaluator updates

        TODO
        ----

        standard library cleanup

            - add types support in places
                - lib-string, lib-list done
                - others not as important, but will work through them over time.

        operators

                - todo: three-way comparison for scalars and array of built-ins
                    - may be wasted effort for any benefit it would bring
                    - should maybe only do this once a decision has been made about an
                        eventual JIT version, as the generated code might better optimise.

            - add more type support in existing ops
                - DONE - added str*pos_int : repeat string
                - DONE - added []string and []uint to + operator.

            - extend compound ops (++,--,+=,-=,*=,/=,%=) to work with globals
                - DONE
                    - setglob now supports all of the above compound operators.
                    - still only work for simple operands on l.h.s.

        dormant functions

12.         - need a way to yield and make a function dormant and re-entrant.
                - this would allow for generators and some other operations.
                - there's no particular priority for this, just a nice to have.

        variable allocation

            - three issues with variables currently:
                1. we cannot use maps for the 2nd dimension local storage as they are too slow
                2. ... so we use arrays instead for backing storage, except we now spend half
                    of our time looking up variable positions in the array with VarLookup()
                3. variables are only stored in pseudo stacks per function and cannot persist
                    beyond the duration of the function's life time.
            - because of the above:
                - a) variable access is sloooooow.
                  b) pointers are pretty useless.
                  c) we'll only ever have call-by-value functions.
            - these are not big issues for the current use cases of the language, however, they
                will be real stumbling blocks to expanding that scope or to building up to a
                compiled or JITed version one day.
            - this is more than highly unlikely in any event, but it would be good to remove 
                this issue, even if just to speed up interpreted variable access.
            - c) call-by-value was partially a design decision anyway. however, we could work 
                around it, to some degree, by passing a more complete description of the var
                in (including function space) and checking for expression/description at Call()
                startup. It would be yet another layer of crap in the system though. Best just
                to stick with the original design here for now. If we ever get to the point of
                using properly allocated storage for vars then we could add a ref/addrOf type
                symbol and handle this right.

            - even if map access could be sped up (and it can, with general Go improvements over
                time and by using an alternate hash key generator. we previously tried this one:
                https://github.com/OneOfOne/xxhash and it performed great, but the basic premise
                was still too slow. the algorithms need to change for var storage for any great
                gains to be had.

            - this is all further complicated due to the fact that we permit interpolation on
                the l.h.s of assignments - it's gonna take someone much cleverer than me to 
                figure out a way of caching name resolution with interpolation active.

            - without thinking about it too much it seems like we need to:

                - either have a 'proper' memory allocator and do the job properly, or
                - find a way to cache the storage index as part of the token.
                    - the caching has been tried already and is a hideous thing, full of edge
                        cases and complications. just caching variables tied to tokens is
                        pretty easy, it's handling identifiers in expression evaluation which
                        is problematic. we would have to pass the tokenised source fully by
                        reference and allow the evaluator and var access routines to modify
                        the source tokens to make this work.

            - with the above in mind it's more than likely we'll just have to accept the current
                performance (which is definitely good enough for what is required) unless a 
                benevolent genius with time on their hands comes along and pimps it up.


        PARTIAL COMPLETION
        ------------------

        Pointer Operations
        -------------------------------------------------------------------------------------------

        DONE: (not that this implementation is of much use for anything currently)
        add unary op: ^a
            this will effectively be our pointer type
            when encountered on r.h.s it will eval to a string "fs.varname" of var a
            when assigned it will be stored as the IValue of p in p=^a ("fsid.a")
            when evaluated p will return its own IValue

        DONE:
        add unary op: *p
            when evaluated *p will return the content of 'a' by dereferencing the IValue.
            on the l.h.s *p will assign to the referenced var 'a'.

        DONE: (partially anyway)
        add l.h.s. deref of *p for assigning indirectly... in doAssign()

        DONE:
        add pointer as a valid field type in structures
            see eg/pointers
            not much to this.. just added ^ as a field type (underlying type is []string)

        NOT DOING:
            any kind of pointer arithmetic or memory allocation pool.

        -------------------------------------------------------------------------------------------
        to make any use of this you'll probably end up having to create state in the global space.
        because we don't spawn objects that live beyond the scope of their local function, pointers
        will likely only be any use when reading state from a parent scope. you could conceivably
        have a function holding space that async threads could access, but the use cases are few
        and far between in any case.
        -------------------------------------------------------------------------------------------
        to make this more like you might expect would involve creating a memory allocator which 
        works outside of normal variable allocation, and this just is not going to occur. it would
        make pointers useful, but they are already at the very edge of what needs to be supported
        in this language. arguably, they are already outside of the remit. the operators are only
        in place because they were easy to reserve and they can have their functionality changed 
        later. i just do not anticipate ever doing this.
        -------------------------------------------------------------------------------------------
        probably won't even be documenting this functionality for now.
        -------------------------------------------------------------------------------------------


1.0.10  new evaluator + VAR enforcement

1.0.9   BSD port, STRUCT support, lower-level filing operations.
        bug fixes and documentation updates


---------------------------------------------------------------------------------------------

LATER
-----

* windows keypress() (getch function):

    * working now, but modifier keys (shift, ctrl, etc) all throw a keypress into 
        the input buffer, effectively triggering the Read. This leaves the go routine
        hanging pending the second part of the keypress even after the timeout value
        has been exceeded.

    * it's not a big issue, but could do with a workaround. seems to be part of the 
        way that ReadConsoleInput and PeekConsoleInput work in Windows. 

    * still some timing issues to deal with. key debounce seems to be around 50-100ms minimum on windows.
        this affects keypress use with a timeout specified, as a timeout may occur before key up and debounce complete.

        * we either need to figure a way to make it wait patiently and report lag or put stricter limits in place.


UNDECIDED
---------

* WHEN...ENDWHEN
    * multiple options in IS?
    * fall-through? veering towards "no" for this.

* ultimately, change interactive mode to use readline or similar with better utf-8 support.
    * as usual, really low priority on this. i only wanted it for Â£ symbols!


