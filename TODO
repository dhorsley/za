

BUGS
----

lots, i'm sure.


TODO
----

    FIXED: added noui build constraint and use CGO_ENABLED=0 and the build constraint in 
        the build script Alpine option. v1.0.14 now builds fine. It has been tested in Alpine
        docker builds and on AWS linux 2 and also no longer throws the startup GL warning either.
        it remains a static, stripped and compressed binary on Alpine.


    * make each platform binary not throw errors when opengl not available.

        - Linux (Ubuntu, Redhat, Debian) : seems fine on recent versions.

        - centos 7 and below have problems with V1.0.14 since the introduction
            of the opengl stuff. they have a 2012 version of glibc as standard.

        - Fedora        : tested. seems fine on fedora release 33.
                           it's probably fine on a lot of older releases too.

        - Windows 10    : UAC, binary stripping and a/v causing problems more
                           so than the Za binary itself. more checks needed.

        - Alpine        : have split out some of the UI functionality to only
                            build when the build tag 'noui' is not set.

                          the build script has been altered to add this tag and
                            to also ensure CGO_ENABLED=0

                          this leaves the alpine build operating as it did in previous
                            versions (i.e. without lib-ui facilities) but for other
                            builds to include lib-ui.

        - FreeBSD       : to test

        - AWS Linux 1+2 : to test - but fully expect it will need to operate like the
                            Alpine build above.


LATER / UNDECIDED
-----------------

    * perform a more thorough division between ui/noui builds rather than between OS.

    * add ref and mut directives/operators for use in function calls?

    In principle, we are generally trying to avoid passing variables by reference to allow for their
    mutation in a call. However, it has proven useful at least a few times when constructing the
    library to allow this. 

    The compromise, so far, was to indicate the variable name with the REF operator rather than
    putting variable names in strings during the call. It makes clear the intent of the use while
    still not mutating the variable during the call. We have no aspirations towards pure function calls,
    however we did want to give clarity for readers of the code what was going on.

    As we have needed to do this ourselves then surely normal programming with the language would
    deem it necessary to allow for call-by-reference or call-by-copy-restore.  This may be the case, 
    but we are still trying to avoid it. 

    In case we do change our mind, then we will likely extend calls to make the REF and MUT operators 
    both act as a literal reference to the variable name but to also pass a usage flag through the call:

        REF n  : read-only reference to caller variable 'n'
        MUT n  : reference to caller variable 'n'. Work with copy during call. On exit, write the result
                    back to the caller variable 'n'.

    To accomplish this we would need to:

        - move the callFunction argument wrangling that happens everywhere to the start of the Call function.
            - this is needed as the arguments are evaluated ahead of the functionArgs comparisions done
                inside Call(). I.e. the required information is lost by that stage.
            - it would also unify the various methods of processing args currently done all over the place.
            - this would possibly also reduce the lock count at function call startup.

        - add code in function arg processing to add a mutable field with "mut" operator (probably quite
            a minor change code-wise as we already have a processing loop for this, we just need a case for
            setting the 'mut' flag.)

        - add code on function exit to mutate caller state with updated values (we already do this to 
            a certain extent for the retval/retvar handling, so this would be an extension.)

        - maybe other stuff i can't think of right now.

    Without those additional changes, ref/mut are usuable as synonyms for ` "variable" `.

    The above would quite clearly be a substantial structure change from how things are now. It's not 
    a lot of code, but it would require much testing. It's made more problematic in that as soon as I start
    ripping that code apart there's a few other changes that I would feel compelled to make while in there.


* add more manual example code in tools/funpages/examples for more functions.
* DONE : add this to the bash startup in interactive mode?  | alias ls="ls -x -w {=term_w()}"
* ultimately, change interactive mode to use readline or similar with better utf-8 support.


