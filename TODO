
TODO
----

- look into rerouting stdin,stdout,stderr for external calls when in repl mode?

  - you can currently run a subcommand interactively by doing something similar
    to below:

    capture_shell(false); coproc(false)
    # run nvim interactively
    nvim test_file
    # za scripts need the -f flag to stipulate the script is coming from a file
    za -f some_other_za_interactive_script

  - this is not 100% depending on the behaviour of the subcommand (e.g. less works, more doesn't)
    we should try to improve this somehow.

  - added a nocap("cmd") function to the startup script.
    - this disables capture and the sub process in order to
      execute cmd. the previous state of capture and sub cmd
      execution are restored after completion and the cmd output
      struct returned.


- macro system

  - syntax - values must be quoted
    - macro [!] [-+] m_name [`"] value [`"]

  - definition
    macro [!] + m_name [`"] value [`"]
    - defines a new macro.
      - if an existing m_name, then redefinition will complete successfully.
  
  - use
    #m_name
    - searched and replaced before tokenisation
    - we may need to also limit the places that this can be used.
      - i.e. repl use is intended.
             normal script lines should be fine.
             during eval() or exec() calls? maybe not?
             inside string interpolation? maybe not?
             inside system() type calls, e.g. | ${..} {..} &{..} =|  et al?
               - these should be fine but there may be some strange buggy cases doing this.

  - deletion
    macro [!] - [m_name]
    - use macro - to remove all macros
    - use macro - m_name to delete a single macro

  - if the ! qualifier is present then a redefinition, deletion or a
    complete macro set reset will emit a console message.

  - storage - macros will be held in a global map[string]string
 
  - example
    path="/tmp"
    macro +options `-l`
    macro +ez `eza #options --icons=always`
    #ez {path}
    - the above will expand before tokenisation so that {...} variable subst can still happen.


  - notes

    - macro expansion should be eagerly evaluated - we cannot effectively tokenise macros without causing
      a host of other problems.
      in the example above #options may be redefined but #ez will still act against what value #options had
      when it was defined.
      use {...} variable expansion instead if more dynamism is required.

    - in practice, this will look a lot like the expansion loop we do for interpolating variables but with 
       a different search syntax (#...) instead of ({...})
       ... with the loop ending when no further expansions have occurred in the last iteration.
       - we should probably check what happens with recursive expansions here also!

    - in reality, this feature would mostly be for REPL use (and definitions in startup scripts).
      however, there are probably some infrequent use cases in real scripts, which means we will also need
      to protect the access to the global macro map against concurrent access with a lock. 


KERNEL PARAMETER TUNING
-----------------------

* TODO: Kernel parameter tuning support
    - sysctl_get(parameter) - get kernel parameter value
    - sysctl_set(parameter, value) - set kernel parameter value
    - sysctl_list(category) - list parameters by category
    - sysctl_persist(parameter, value) - set parameter persistently
    - sysctl_validate(parameter, value) - validate parameter value
    - sysctl_categories() - list available parameter categories
    - sysctl_restore_defaults() - restore default kernel parameters


CORE FIREWALL DETECTION & MANAGEMENT
------------------------------------

* TODO: Active firewall detection (not just available)
    - nftables: kernel module check + active rules detection
    - firewalld: D-Bus connection + active service detection  
    - pf (BSD): CLI wrapper + active rules detection
    - Windows Firewall: WMI connection + active profiles detection

* TODO: Unified firewall API
    - fw_capable() - detect active firewall with capabilities
    - fw_guard() - safe guard for firewall operations
    - fw_enable(firewall_type) - enable specific firewall
    - fw_disable() - disable current active firewall
    - fw_add_rule(protocol, port, action) - add firewall rule
    - fw_remove_rule(protocol, port, action) - remove firewall rule
    - fw_list_rules() - list current firewall rules
    - fw_get_stats() - get firewall statistics

* TODO: Platform-specific native library integration
    - nftables: github.com/google/nftables (direct netlink)
    - firewalld: D-Bus interface (direct service communication)
    - Windows Firewall: WMI/COM interface (direct Windows API)
    - pf: CLI wrapper (no native library available)

* TODO: Privilege checking and security validation
    - fw_has_privileges() - check if user has firewall management permissions
    - Platform-specific privilege validation (root, sudo, doas, Windows admin)
    - Automatic privilege requirement detection and error reporting

* TODO: Cross-platform consistency
    - Same API functions work across all supported platforms
    - Automatic platform detection and appropriate firewall selection
    - Unified error handling and status reporting


PLUGIN ARCHITECTURE FOR CUSTOM FIREWALLS
----------------------------------------

* TODO: Custom firewall plugin registration system
    - fw_register_plugin(firewall_type, handler_functions)
    - fw_unregister_plugin(firewall_type)
    - Plugin detection integration with native firewall detection
    - Plugin capability reporting and validation

* TODO: Plugin interface specification
    - fw_detect() - detect if firewall is active
    - fw_enable() - enable the firewall
    - fw_disable() - disable the firewall  
    - fw_add_rule(protocol, port, action) - add firewall rule
    - fw_remove_rule(protocol, port, action) - remove firewall rule
    - fw_list_rules() - list current rules
    - fw_get_stats() - get firewall statistics
    - fw_capabilities() - list of supported capabilities

* TODO: Example plugins for legacy firewalls
    - iptables plugin (CLI wrapper)
    - ufw plugin (Ubuntu firewall)


ADVANCED FIREWALL FEATURES
--------------------------

* TODO: Real-time firewall monitoring
    - fw_monitor_events() - real-time event streams
      - these should be unified so we don't need, for example, separate event lookups such as:
        - fw_nftables_events() - netlink event monitoring
        - fw_firewalld_events() - D-Bus event monitoring
        - Windows Firewall events - WMI event monitoring
        - pf events - CLI-based event monitoring

* TODO: Rate monitoring and statistics
    - fw_rate_monitor() - hits/second monitoring
    - fw_rate_alert(threshold) - rate threshold alerts
        - how to do this without a separate event loop?
        - ... or spin one up dynamically when monitors added?
    - Rate history tracking and anomaly detection
    - Performance impact monitoring


FIREWALL EVENT LOGGING AND AUDIT
--------------------------------

* TODO: Firewall event logging and audit
    - fw_log_events() - capture firewall events
    - fw_audit_trail() - comprehensive audit logging
    - fw_compliance_report() - compliance reporting
    - fw_security_analysis() - security analysis and recommendations

    NOTES
    -----

    * All firewall operations should respect an "only one active firewall" principle
    * Native libraries should be used where possible (nftables, firewalld, Windows Firewall)
    * CLI wrappers only when no native library is available (pf)
    * Security and privilege validation is critical for all firewall operations
    * Cross-platform consistency is a key design principle
    * Performance and resource efficiency are considerations


LATER / UNDECIDED
-----------------

    * add install note for windows w/wsl stating that sudoers file may need 
        updating with : Defaults env_keep=WSL_DISTRO_NAME
        and possibly other env vars, depending on user requirements.

    * probably we require many other similar notices/warning/info about OS specific caveats.



