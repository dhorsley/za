

BUGS
----

lots, i'm sure.


TODO
----

    * make each platform binary not throw errors when opengl not available.

        - Linux (Ubuntu, Redhat, Debian) : seems fine on recent versions.

        - centos 7 and below have problems with V1.0.14 since the introduction
            of the opengl stuff. they have a 2012 version of glibc as standard.

        - Fedora        : tested. seems fine on fedora release 33.
                           it's probably fine on a lot of older releases too.

        - Windows 10    : UAC, binary stripping and a/v causing problems more
                           so than the Za binary itself. more checks needed.

        - Alpine        : have split out some of the UI functionality to only
                            build when the build tag 'noui' is not set.

                          the build script has been altered to add this tag and
                            to also ensure CGO_ENABLED=0

                          this leaves the alpine build operating as it did in previous
                            versions (i.e. without lib-ui facilities) but for other
                            builds to include lib-ui.

        - AWS Linux 1+2 : Use the Alpine build on AWS linux and all is well.

        - FreeBSD       : to test


LATER / UNDECIDED
-----------------

    * coalesce VAR/INIT ? (IN-PROGRESS)
        - (DONE) this may mean adding [] as a syntactical element to VAR
            - eg. var a int  vs.  var a [] int
            - types are:
                bool, byte, uint, int, float, string
                []bool, []byte, []uint, []int, []float, []string
                nil, assoc (map)

        - (DONE) or, var s struct_name
        - (PARTIAL) and var ary_s []struct_name
            - added the syntax support, however, za currently implements these
                as []interface{} so it accepts the declaration, but does not
                initialise the elements. you must still do something like:
                > var q struct_name
                > var z []struct_name
                > z[x]=q
                > z[x].element_name=value
            - will update to something more robust if needed later.

        - (DONE) needs to also allow for fixed size arrays, e.g. [20] int

    * allow multiple variable declarations?
        - (DONE) eg. var a,b,c int

    * struct default values.
        - (NOT DONE) i.e. struct sn; a int [ = value ]; endstruct
        - this should be an easy addition.

    * need to (re)consider structs as struct member types.
        - initially, this did not seem like a useful concept for the language use case.
        - in all honesty, it still doesn't, but it might allow for other use cases.
        - it also adds a fair amount of complexity that we may be better without.
        - we currently have 'mixed' as a type meant to hold exotic values in struct member fields.
            however, this is currently a bit broken :) mainly because it is currently unused.
            we should either fix up 'mixed' types in structs or replace with something orthogonal
            to the var/init scheme. (or just ignore this complexity, without a solid use case.)

    * (NOT DONE) update online manual with above details.

    * take another look at allowing 'end' as a synonym for all the end* statements:

            enddef
            endstruct
            endif
            endwhen
            endfor
            endwhile
            endwith
            endtest

        - the only issue i can see with this is the way we use the lookahead() call for finding
            block/scope ends. it may need a rewrite. have to think it through:

            - endstruct would be fine most likely as none of the other constructs can 
                nest inside of it.
            - we could possibly just add struct,if,when,for,while,with,test as nest-begin components
                in lookahead(), which I believe it can already handle but have to check.
            - if it can, then we just allow any 'end' (i.e. C_End) as a synonym for the specific case we
                are searching for during the call.
            - this also implies we breakout the specific use of "end" in lex.go as a synonym for
                C_Enddef only, and make a new C_End token.
 
            - still have to check for other places this may break things, aside from lookahead().

                At this point is there really much difference between {} use and statement_type...end?

                I still consider curly braces to be less readable in general and the specific
                use of a full end* statement can also be more readable to some people all of the
                time and to everyone when looking at nesting depths in long stanzas. i.e. does
                that end belong to the FOR or the IF 3 screens up? some people prefer the clarity,
                other people don't mind adding comments instead and yet others just don't care
                either way. However, I care for myself and I'm the one using it :)


    * perform a more thorough division between ui/noui builds rather than between OS.

    * add ref and mut directives/operators for use in function calls?

    In principle, we are generally trying to avoid passing variables by reference to allow for their
    mutation in a call. However, it has proven useful at least a few times when constructing the
    library to allow this. 

    The compromise, so far, was to indicate the variable name with the REF operator rather than
    putting variable names in strings during the call. It makes clear the intent of the use while
    still not mutating the variable during the call. We have no aspirations towards pure function calls,
    however we did want to give clarity for readers of the code what was going on.

    As we have needed to do this ourselves then surely normal programming with the language would
    deem it necessary to allow for call-by-reference or call-by-copy-restore.  This may be the case, 
    but we are still trying to avoid it. 

    In case we do change our mind, then we will likely extend calls to make the REF and MUT operators 
    both act as a literal reference to the variable name but to also pass a usage flag through the call:

        REF n  : read-only reference to caller variable 'n'
        MUT n  : reference to caller variable 'n'. Work with copy during call. On exit, write the result
                    back to the caller variable 'n'.

    To accomplish this we would need to:

        - move the callFunction argument wrangling that happens everywhere to the start of the Call function.
            - this is needed as the arguments are evaluated ahead of the functionArgs comparisions done
                inside Call(). I.e. the required information is lost by that stage.
            - it would also unify the various methods of processing args currently done all over the place.
            - this would possibly also reduce the lock count at function call startup.

        - add code in function arg processing to add a mutable field with "mut" operator (probably quite
            a minor change code-wise as we already have a processing loop for this, we just need a case for
            setting the 'mut' flag.)

        - add code on function exit to mutate caller state with updated values (we already do this to 
            a certain extent for the retval/retvar handling, so this would be an extension.)

        - maybe other stuff i can't think of right now.

    Without those additional changes, ref/mut are usuable as synonyms for ` "variable" `.

    The above would quite clearly be a substantial structure change from how things are now. It's not 
    a lot of code, but it would require much testing. It's made more problematic in that as soon as I start
    ripping that code apart there's a few other changes that I would feel compelled to make while in there.


* add more manual example code in tools/funpages/examples for more functions.
* DONE : add this to the bash startup in interactive mode?  | alias ls="ls -x -w {=term_w()}"
* ultimately, change interactive mode to use readline or similar with better utf-8 support.


