
CHANGE LOG
=============================================================================================

1.0.15
======

    fixes
    -----

    * testing replacement callstack id+space allocator.
        - using a sequential modulus fn instead of random numbers now.
        - will need to add a couple more things before it's considered stable, but
           it is already much faster that the previous shitshow.
           - needs cli opts for setting gnfsModulus constant
           - needs cli opts for other related allocator tweaks
           - needs to actually deallocate reservations too!
           (sort of done now - need to check over it)
                - currently, mem use grows to a max (related to MAXFUNCS).
                - it should keep working at this depth without further allocation
                   however, the callstack doubles in size on demand up to that max.
                - this didn't happen with the old allocator, just need to figure out
                  what i turned off while frigging around with this! :)
                - we can happily calculate larger ackermanns  i.e. eg/ackermann 3 12 (or 4,1 or 5,0)
                   and fib with/without tail recursion faster too.
        - this was all needed as the old allocator had a couple of problems:
            1. random number use, even using faster rng involved calling sys.time and other hacks.
            2. check for next available slot was basically counting up from zero looking for next
                 instead of starting at around the right place.
            3. because of 1. and 2. recursion, well, sucked balls.
        -
        - some checks completed:
            - had to rework a few things around locks, parser instances and lhs/rhs ident tables
            - pretty substantial speed increases seen for general processing and eval work
            - less small allocs + gc, but still plenty that can't be avoided because of 
                dynamic typing parts of the code. will just have to live with this.
            - speed increases vary from ~15% to 50% increase depending on the nature of the test.
                - e.g. eg/regex down from ~35 seconds to ~16secs.
                -      eg/addition_loop down from about ~6.5 to ~5.1secs
                -      similar gains seen in other test code.
            - probably still some buggy things around as this was not exactly a precise operation!
                - maybe some issues with name binding in the REPL mode
                - probably some important mutices missing, but tests seem okay so far:
                    - weighttp didn't present many issues running eg/web fetching a dynamic page:

        $ weighttp -n 1000 -t 3 -c 50 -k http://127.0.0.1:8080/fun/awsip
        .
        .
        .
        finished in 0 sec, 119 millisec and 390 microsec, 8375 req/s, 28756 kbyte/s
        requests: 1000 total, 1000 started, 1000 done, 1000 succeeded, 0 failed, 0 errored
        status codes: 1000 2xx, 0 3xx, 0 4xx, 0 5xx
        traffic: 3515640 bytes total, 124000 bytes http, 3391640 bytes data

                - the weighttp test above broke down at high concurrency / high frequency, but 
                  was to be expected.
                  (eg. -n 10000, -t 6, -c 250 : this kind of use is tricky for dynamic pages)

                - higher frequency was still acceptable on static workloads:

        $ weighttp -n 10000 -t 6 -c 250 -k http://127.0.0.1:8080/index.html
        .
        .
        .
        finished in 0 sec, 196 millisec and 853 microsec, 50799 req/s, 47773 kbyte/s
        requests: 10000 total, 10000 started, 10000 done, 10000 succeeded, 0 failed, 0 errored
        status codes: 10000 2xx, 0 3xx, 0 4xx, 0 5xx
        traffic: 9630000 bytes total, 1170000 bytes http, 8460000 bytes data


                - many places still not touched for small speed bumps, but I've about given up
                  at this point. quite minor gains to be had without re-implementing as a
                  byte-code interpreter instead of direct execution.

                  i'm fairly happy with the speed + stability it is at now, but there may
                  be a byte-code implementation somewhere in the future, just doesn't feel
                  necessary yet. 

                  i think i will work again on some stability, tidying and feature finish then kick
                  this version out of the door as 1.1.0.

    * fixed trapInt handler (ctrl-c)
        - needed repointing to main ident space post changes above.
        - it was also pretty broken since we added multiple return values.
        - ... and was using the wrong parser in the interrupt handler.
        - should be okay now!
        - still want to add other event handlers, mainly for sig winch to begin with.

    * localised loops[], depth[] and lastConstruct[]
        - this allowed us to remove *a lot* of mutex locking. these were previously
            globally shared as we had thoughts regarding function re-entrance.
            if this still happens, we'll find another way - the shared storage was too slow.
        - we could possibly move these entirely into the parser struct later if needed
            to permit some kind of yielding facility.

    * moved the program counter from local var to each parser's struct. 
        this saved us needing to take copies of it for error reporting, but otherwise
        a negligable speed change - just less GC.

    * added timing checks at debug_level>10 for lex/parse-to-ast of global, functions and modules.

    * moved binaryLed inline manually to dparse function. saves a function call which was
        happening far too frequently.

    * removed siglock mutex.

    * the removal of the mutices above and other changes have contributed to around a 20% speed up in eval
        and general statement processing speed.

    * added identifier subtype and check for builtin const/library calls in lex.go
        - this should speed up some types of code a little. was previously always checking these
            during identifier lookups in evaluation. it also picks up user defined functions if
            they have already been encountered by this lexing step.

    * updated za.vim


    language features
    -----------------

    Added some unary string operators. The following operators are currently (and experimentally) enabled:

        - $lc "string"      : to lower
        - $uc "string"      : to upper
        - $st "string"      : string trim (whitespace "\ \t\n\r")
        - $lt "string"      : left trim   (   "        "        )
        - $rt "string"      : right trim  (   "        "        )

        - example:

            >> q=read_file("/usr/share/dict/words").split("\n")
            >> foreach a in q ?> `#.has_start("d")` -> "$uc #"
            >>   println a
            >> endfor

    library features
    ----------------

    * added mem_summary() :  returns list of variable storage sizes per function space allocation.
    * added some more lib calls: 
        - os: can_read, can_write, parent, fileabs
        - conversion: dtoo, otod
        - os: is_symlink, is_device, is_pipe, is_socket, is_sticky, is_setuid, is_setgid
            - these all require a signed integer (int) as parameters. i.e. int(file.mode) from dir().
    * updated info for ibase, wininfo, int64, zainfo, byte, floor, ui_w, time_*() lib functions.


1.0.14
======

    fixes
    -----

    * updated vim syntax file
    * added 'f' suffix on numeric literals for enforcing float type.
    * library function name review (for consistency)
        - breaking changes: some function name changes have had underscores added/removed for consistency.
    * added expect_args() to all standard library functions where it makes sense to.
    * added { and } as outer delimiters for ENUM as well as ( and )
    * altered ENUM to accept expressions in member assignments.
        - this can contain circular references to earlier members such as:
        > enum colours { r,g=10,b=colours.g*3,w }
        > print ref colours.enum_all
          [1 10 30 31]
    * updated append_to() help
    * added support for reversed count ranges in .. operator. e.g. 20..5:
        - eval_ops/ev_range() amended. returned ranges are always int-based.
        - range start and end may be specified as uint(64),int(64) or float, but types of start and end must match.
        - floats should be specified in parentheses where necessary to avoid confusion.

    * finally got around to adding a type check on struct build.
        - currently permitting: bool, int, uint, float, string and mixed.

    * altered PROMPT to permit validator regex to be built from an expression instead of a literal.

    * changed windows default ansi setting to true.
    * removed -l option.

    * added SHOWDEF back in. the output is occasionally a little off due to semicolons, but still has some use.
    * fixed ui_cursor_visible() input type check.
    * oops, fixed issue when auto-allocating from size 0 in array assignment. (sz test in eval.go/vsetElementi func)

    * Fixed stuck FOR loops when loop var already exists with different type (actor.go/C_For)
        - now throws an error report when var already declared.
        - *except* when var is an int
        - this highlighted an issue around whether loop variables should be disposed of post-loop:
            - as it stands, sequential loops need to use different loop var names so that we do not
                have to dispose of them when a loop ends (which can be useful).
            - this will most likely only occur when a FOR loop tries to use the same var name as a
                FOREACH loop in the same function block.
            - it's probably fine as it is, but should review soon.

    * struct default values:
        - You may now supply a default value inside a struct definition for a field.
        - Format: struct sn; a int [ = value ]; endstruct
        - Example:
            struct person
                first_name string
                surname string
                age int = 18
            endstruct
        - on initialisation with VAR the defaults are set.
        - this is currently only implemented with scalar creations of struct in VAR.
            - still need to add default value support in, e.g., var people []person
            - should just be a virtual copy/paste job, but testing current implementation first.

    * added map[string]interface to sort(). sorts on key instead of value.
    * added pgup/pgdown to wrappedGetCh() for use in keypress(). (dec 15/dec 14)
        - untested in windows. windows is also missing copy/paste functionality.


    language features
    -----------------

    Several changes are underway to support windowing features through opengl.
    This will be done with a subset of the Pixel Go library.

    PLEASE NOTE: the default version currently only works (correctly) on Linux with certain
    libraries installed and a particular level of OpenGL support (v3.3). (3.1+ if you hack it a bit)

        : required support and workarounds for opengl(es)1/2/3 can be found through the wiki pages
        : for pixelgl, glfw, etc.
        : we managed to get this working on a deliberately feeble test rig of:
        :    onemix3s/win10 with ubuntu 20.04 vm (opengles2 with vm video hw acceleration off).
        : ... just to say, it's doable - and probably fairly easily depending on the hardware.

        - Windows tested some more.. It kinda works now. Still working through tests.
        - FreeBSD still untested.
        - Alpine/AWS Linux 1/2:
            - works (with warning) for glibc build.
            - works fully with Alpine build. (i.e. no lib-ui support compiled in) [./build alpine upx]
        - Fedora: works fine. (v33+)
        - Ubuntu: works fine. (v18+)

    Operating with the -u startup arg will only have any effect on builds with lib-ui compiled in. (i.e. !noui tag)

    * added some more types to VAR. (and INIT functionality merged into VAR)
    * added support for an identifier list in VAR: eg var a,b,c int = 42
    * added support for [] and [size] as prefix to type in VAR.


    library features
    ----------------

    Wrapper around Go Pixel library. Early stages, experimental.
    The Pixel library gives us a massive amount of extra capability, but does come with
    some performance issues around threading and supported platforms.

    Eventually the hope is that it will all be switchable on each platform with the -u flag.

    * added UI lib calls, so far:
        - ui_init, ui_close,
        - ui_closed (has the close button been pressed?)
        - ui_handle (returns internal window id)
        - ui_clear, ui_update
        - ui_title, ui_text
        - ui_new_draw (create a draw object)
        - ui_draw_reset (clear object content)
        - ui_batch (send draw object to update batch)
        - ui_batch_clear (reset a draw object)
        - ui_batch_draw
        - ui_pp (create a point)
        - ui_polygon (connect prior points), ui_circle (connect prior points)
        - ui_rectangle, ui_circle_arc, ui_line, ui_bounds
        - ui_colour, ui_set_smooth, pic_load, pic_bounds, ui_centre
        - ui_new_sprite, ui_sprite_draw
        - ui_new_matrix, ui_mat_move, ui_mat_rotate, ui_new_vector
        - ui_get_code (find a button (keyboard/mouse) depression constant)
        - ui_just_released, ui_just_pressed, ui_pressed
        - ui_get_monitors, ui_primary_monitor, ui_set_full_screen, ui_windowed
        - ui_w and ui_h

    * other calls are in progress
        - mainly will be wrappers around basic Pixel functionality
            so that we have at least some support for windowed applications.
        - we'll add a number of UI elements over time.

    * added -u startup flag to indicate requirement for opengl access/windows.

    * see eg/ui for example code loop.

    * early testing of performance indicating reasonable results.
        - for very low object count windows, frame rates anywhere between 150-1000
        - low object count, around 100 fps.
        - 30-60 fps achievable if the draw count is kept down with batches.
        - you wouldn't ever want to try writing a game with this language, but it
            is able to keep up on simple GUIs.

    other stuff:

    * added more strictness checking of types in almost all existing library calls.
        - we have added some more generalised parameter checking for types in the
            standard library. Where varargs are expected it is more relaxed.

    * added randf() : random float between 0 and 1. (or between 0 and n if n supplied as argument)

    * added check in VAR to explicitly prevent redeclaration.


1.0.13
======

    fixes
    -----

    * changed deferred unlocks around variable reads to immediate for small speed improvement.
    * added function concurrency counter to lower lock requirements
    * inlined vgeti: it's messy, but faster. still just polishing a turd though.
    * changed statement in Call() to a pointer to Token inside the phrase.
        - dropped from around 400ms in profiles over 8 secs to ~100ms.
    * added check for uninitialised variable use as identifiers in eval.go (fn identifier())
        - an exception to this is module and enum names that have been created during execution.
    * updated a couple of eg/ examples to reflect the uninitialised var change above.
        - ( mainly initialising lists which are appended to )
    * added "t" (translate) mode for tr() call. it is still nowhere near as useful as the full tr tool, but
        it covers most basic requirements. still could do with a negation and upper/lower option.
    * deprecated optional mutex locking.
        * locks are now always enforced by default except in a few safe areas.
        * the locks() library call and the -l startup option will be removed in 1.0.14
        * this has obviously had a negative effect on the language speed, but it is a fairly
            minor reduction in most cases. (<1%). It might get worse in hot code depending 
            on the nature of operations, but it was worth the trade-off for operational safety.
    * changed system() and Copper() calls to cause assignation of struct instead of string when
        using the =| operator. This allows for an occasionally more readable use of =|.
        - Returned struct fields are .out (stdout), .err (stderr), .code (command status
           code) and .okay (summarised status).
        - The last() and last_out() lib calls still work as before should you need them.
    * added default behaviour in interactive mode to print the result of submitted expressions
        - this only happens when a) not an assignment, and b) no evaluation error occurred.
    * added support for cursor keys in keypress(). left, right, down, up return 8, 9, 10
        and 11 respectively.
    * lexer - forced numbers to end when followed by 2 dots
    * made WHEN condition optional ("when a" above could be "when"). the constant "true" is used when
        the condition is missing.


    language features
    -----------------

    * added operator <-
        - usage: <- file
        - reads file content as a string literal
            - e.g.  on <- "text_file1" == <- "text_file2" do print "same"
        - added support for use in FOREACH

    * added description hint option in INPUT ... PARAM statement for error messages. (param #4)
        - e.g.
        > input mq param 1 "Maximum queue length"

    * added (very) simple max column wrap for panes.

    * added statement ENUM
        - enumerations can be defined in this way:
            > enum colours ( red=1, green=2, blue=4, mask=7 )
        - for numeric constant type values, when missing, they assume the previous value + 1
        - the initial default value is int(1)
        - string literals may also be used as values.
        - strings and numeric types may be mixed within the same enum declaration.
        - further examples,
            > enum authors ( bill="William Shakespeare", george="George Orwell" )
            > enum bitpos ( l0=1,l1=2,l2=4,l3=8,h0=16,h1=32 )
            > enum rainbow ( red, orange, yellow, green, blue, indigo, violet )
            > enum mixed ( one=1, two=2.0, three, pi=3.141, four=4, author="Orwell")
            - the final mixed enum has these values:
                [ 1, 2.0, 3.0, 3.141, 4, "Orwell" ]
        - enum addressing:
            - an enumerated label may be dereferenced using the form:
                > enum_name.enum_label
                # example:
                > colours.blue
                > 4

    * added HAS expression condition type to WHEN...ENDWHEN
        - "HAS expression" clause causes the initial WHEN condition to be ignored and
            a clause truth test is performed against the presented HAS expression instead.
        - on falsehood, subsequent clauses are tested with the original condition,
            except in the further HAS clauses of course.
        - as before, WHEN clauses continue to match on a first come-first served basis.
        - context help and manual still need updating for new clause type.
        - the HAS clause essentially acts as our if..else if..else if..end method, but 
            it also allows for some other alternative arrangements in conjunction with
            IS, CONTAINS and OR clauses.

        - the HAS keyword name may yet change for an alternative if we can think of 
            anything suitable.  Things like SATISFIES, ADMITS, MEETS, CONCURS and a few other 
            alternative were just too wordy... and yes, I know we have CONTAINS, but
            that one is up for barter too.

    * added ternary (query) operator:
        - syntax: ?? expr true_expr false_expr
        -   i.e.: ?? (ternary if) expr (then) true_expr (else) false_expr
        - see eg/nestdepth for example in near functional style

    * added s..e operator for generating an array range. value types of expressions
        s and e must match each other, and the generated range is of the same value type.
        - s must be lower than e for all int types
        - accepted types are currently int, int64 and uint.
            - it would probably be a fairly simple task to extend this scheme.

    * forced, combined example:

        a=rand(50)
        when a
        is 10
            println "a is 10"
        has a in 1..9
            println "a is less than 10"
        has a>10
            println "a is between 11 and 50"
        or
            println "some other value"
        endwhen

    * added basic filter and map operators:

        - filter is ?> and map is ->
        - both accept a list on the l.h.s and a string on the r.h.s
        - both accept a # char in the string as a substitute for each l.h.s value
        - both produce a list of the same type as input
        - both accept lists of bool, uint, int or float
        - filter has a slightly higher precedence than map
        - reduction will probably not be implemented as it can be conveyed with 
            a user-defined function or library call as with max() and avg() below.

        - may be worth considering a way of auto-promoting larger filter and map operations
            to parallel tasking by splitting the l.h.s. 
            - would require some kind of local/remote pipeline and some resiliency on failed
                transfers and result gens. 
            - this is pretty far out of scope for the language so it will probably gather dust.

        - update: added support for arrays and maps of simple interface{} types.
            - this means that array literals should now be supported too.

        - examples:

     >> print 1..20
        [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]

     >> print  1..20 ?> "#>5 and #<15"
        [6 7 8 9 10 11 12 13 14]

     >> print  1..20 ?> "#>5 and #<15" -> "#*3"
        [18 21 24 27 30 33 36 39 42]

     >> print ( 1..20 ?> "#>5 and #<15" -> "#*3" ) ?> "#>29"
        [30 33 36 39 42]

     >> print ( (1..20 ?> "#>5 and #<15" -> "#*3") ?> "#>29") . avg
        36

     >> print ( (1..20 ?> "#>5 and #<15" -> "#*3") ?> "#>29") . max
        42

     >> print list_float(70..90) -> "deg2rad(#).sin"
        [0.9396926207859084 0.9455185755993167 0.9510565162951535 0.9563047559630354 0.9612616959383188 
         0.9659258262890683 0.9702957262759966 0.9743700647852352 0.9781476007338056 0.981627183447664 
         0.9848077530122081 0.9876883405951377 0.9902680687415703 0.9925461516413221 0.9945218953682734 
         0.9961946980917454 0.9975640502598242 0.9986295347545738 0.9993908270190958 0.9998476951563913 1]

    * you may also filter against simple assoc array types with string keys and value types of bool, int, uint, 
        float and string. see eg/op_filter for basic example of assoc array filter and map.

        PLEASE NOTE:

            These operators are very naive. They will consume a lot of memory if you let them. They do not
            do anything clever with list manipulation, generators, yielding, comprehension or any other
            single thing that would help lower resource cost. They just brute force over the lists.

            This may improve in the future if heavily used. Likely not though. For now you can expect a
            very long list of numbers (e.g. 100 million) to take a minute or two to filter or map. 
            1 Million items will probably take a couple of seconds.

            We will add support for []struct and map[string]struct later if required. (# would probably have 
            to stand in for the variable name in the case of arrays. i.e. new_array = old_array ?> `#.name=="smith"`;
            or something similar. not sure about syntax for map[string]struct yet, but would likely be the same! )

    * statement line calc (again!) (lex.go + actor.go)
        - improved again - remains to be seen if it is actually correct now. needs more test data.
        - disabled SourceStore allocation and use - shouldn't be needed now.
        - just using the .Original text from phrase for reporting now.
        - i think the line calc in TEST or ASSERT may still need adjusting. will fix in 1.0.14.

    * release_id() on windows now returns "windows"


    library features
    ----------------

    * added library calls:
        - enum_names("enum_name")     : returns a list of labels for a given enumeration
        - enum_all("enum_name")       : returns a list of values for a given enumeration

    * added library call permit("flag_name",bool) to amend strictness of some run-time behaviours:
        - permit("uninit",bool)         : uninitialised variable use warning.
        - permit("dupmod",bool)         : duplicate module import warning.
        - permit("exitquiet",bool)      : smaller exit error messages

    * added capture_shell(bool) call. True (default) ensures output of commands in parent shell are captured.
        - false will disable stdout capture so that commands such as ssh will operate correctly.
        - this is currently limited to parent shell { coproc(false) } activity.
        - in the normal child shell output will always be captured.

    * added json_query() call. this is just a wrapper around gojq for simple queries:
        https://github.com/itchyny/gojq

        - pretty great software - saved me a ton of work! :)
        - will have to see what impact this has on binary size, performance, etc before
            deciding if we should just generate a more basic version of our own. I really
            would like to keep this package in place though. it's going to help a lot when
            using this language with cloud-based tooling (aws and similar).

    * added btoi() and itob() lib calls for converting bool to/from int.

    * added zip() and scan_left() list library functions.
        - zip accepts arrays of bool, uint, int, float64, string and mixed (interface type)
        - scan_left (currently) accepts arrays of int and float64
        - zip will interleave the elements of two arrays
        - scan_left performs a cumulative operation against each element of an array, with the resulting
            value pushed into a new array. a seed value can be set to use against the head element.


1.0.12  new model for identifier binding.

        * finally replaced the identifier lookups with something approaching a name
            binding scheme. the language should be somewhat faster now.

            - BREAKING CHANGE: as part of this rework we have had to remove support 
                for l.h.s. variable interpolation. it may be re-introduced later if
                necessary, but it will always suffer from slower relative 
                performance due to its nature.

            - All functions, including global/main are now pre-parsed on first call
                to tag identifiers with allocation slots in local storage.

            - Where evaluation is, by necessity, more dynamic, lookups are still
                performed instead. 

        * some example code removed that required l.h.s. interpolation.

        * modified evaluator to not throw an immediate error on illegal array access.
            - i.e. variable not found in v[e].
            - this allows for comparing v[e]==nil (or nil==v[e]).
                - this results in quicker empty element checks than !key("v","e")
            - may change back yet, haven't figure out all the downsides yet.

        * added and, or and not as synonyms for &&, || and !


1.0.11  SUMMARY
        multiple return value handling
        simple in-expression assignment
        result chaining
        multi-line REPL input
        compound assignments and sqr,sqrt operators 
        pre/post increment operators
        split interpolation into local replacement and evaluation types.

        DETAILS

        * breaking change - renamed start() and end() to hasstart() and hasend()
        * breaking change - adjusted some functions to return structs instead:
            - dir() tokens() zainfo() web_get()
        * breaking change - adjusted fields() to only return an array (F[])
            - it was bogging down the var count per function when you used fields()
                on a string with a large number of fields.

        * experimental - added partial support for module namespaces.
            - modules must have filenames exactly matching their namespace name (i.e. no extensions)
            - namespaces must follow conventional identifier rules (no hyphens, start with letter, etc)
            - on function call, a reference such as namespace.funcname(q) will call function "funcname"
               from module file "namespace" with args "q".
            - without a namespace and dot a plain funcname should call the last defined version 
               that it can find. (defined during execution of the current function space)

            - no idea if this will work properly yet, but shouldn't interfere with current naming.
            - see eg/func.namespaces for example.

            - added a filter for module filenames ending in .mod. these should work as well as module
                names without extensions now.

            - no plans to extend this into variables/struct at all. just a convenience facility.
            - no plans for module aliases. this point may change though.


        * added regex operators:

                ~  : direct match           (result:bool)       e.g. "abcd" ~ "d" => true
                ~i : insensitive match      (result:bool)       e.g. "abCd" ~i "c" => true
                ~f : filtering match        (result:[]string)   
                    - e.g. "abcd" ~f "."    => [ "a", "b", "c", "d" ]
                    - e.g. "abcd" ~f ".{2}" => [ "ab", "cd" ]

                    - e.g. in iteration:
                        >> foreach c in "abcdef" ~f "."
                        --   println "__",c,"__"
                        -- endfor
                        __a__
                        __b__
                        __c__
                        __d__
                        __e__
                        __f__
                        >> foreach c in "abcdef" ~f ".{2}"
                        --   println "__",c,"__"
                        -- endfor
                        __ab__
                        __cd__
                        __ef__

    
        * added str * pos_int : repeat string operator

        * added []string and []uint to + operator.

        * added IN operator for arrays: a in b returns true if value a present in ary b
            - can be negated thus: ! a in b
                - operands bind less tightly to logical negation than IN.

        * added simple scalar assignment in r.h.s. expressions.
            - the value of the expression is the same as without the assignment involved.
            - only simple direct assignment to locals is supported.
                - i.e.  print a=10    # this is fine
                -       print a[0]=10 # not good
                -       print g=10    # not good if g is a global
            - extended compound ops (++,--,+=,-=,*=,/=,%=) to work with globals
                    - setglob now supports all of the above compound operators.
                    - still only work for simple operands on l.h.s.

        * comma operator: tldr; there isn't one
            - behaviour is, um, sporadic, at best. should try to avoid it currently.
                - i.e.
                  print b=a,a+=b    # this is fine, will work as expected because the statement
                                    #   processes the commas.
                  b=a,a+=b          # only b is assigned here (with initial value of a)
                                    #  normal parsing of expressions considers a comma an end of expr.
                                    #  so the a+=b would be ignored.

                - this currently works:
                    a,b,c=[1,2,3]

                - ... but this won't:
                    a=1,b,c=[2,3]

            - this behaviour may change, it's a fairly simple amendment. but not sure that
                the use cases would justify it yet. 

        * return values:

            - modified return command to return either a single value or an array of values depending
                on the argument list provided to it.

            - amended doAssign() to handle a comma separated list on l.h.s.
                - rules are currently (but may change yet):
                    - #lhsargs > #rhsargs : syntax error
                    - #lhsargs < #rhsargs : all return values returned to lhs var as an array
                    - otherwise, a direct left-to-right mapping.

            - handling for multiple return assignment is pretty slow at the moment. still working on 
                improving this, but should be working now.

            - e.g.
                define swap(a,b); return b,a; enddef
                x=10; y=20; x,y=swap(x,y)
                println x," ",y
             >> 20 10

            -   x=swap(x,y)
                println x
             >> 20 

            -   x,y,z=swap(x,y)
             >> Error in evaluation
             >> not enough values to populate assignment

            -   # with result chaining, mentioned below:
                x=10
                y=20
                x,y=x.swap(y)
                print x
                20
                print y
                10

        * added basic multiline entry to repl
            - checks for a few of the nesting token types and keeps accepting input
                until they are resolved.
            - changes to a continuation prompt during extended input

        * experimental - added result chaining

            * e.g. a.b.c.d : passes the result of expression 'a' as the first argument to b and so on.
            *        a.b(x): makes a call like b(a,x)

            * as function arg types are not checked this can cause silent failures currently.

            * feature may be removed or amended at short notice before final release.
            * this feature does not currently work *directly* with literals.

                * in order to use with numeric literals they must be parenthesised, e.g.
                    - define double(x); return x+x; enddef
                    - print (3).double
                    > 6
                    - print ("test").double
                    > testtest
                    - print "test".double
                    > testtest


            * if a.b is a field reference 'b' of struct 'a' then it will take priority over chaining.


        * added +=, -=, *=, /= and %= for local and global scalars.
            - (experimental) added support for array elements and struct field references
                on the l.h.s. of the compound operators above.
            - also added for -- and ++. in expressions pre- and post-inc/dec are still supported.
            - The SETGLOB statement must be used for global scope assignments

            * PLEASE NOTE! these operations are in fact slower than their long-hand equivalents.
                a copy of the whole expression is made and then manipulated in order to
                enable them. As the memory for the copy is allocated dynamically you should
                avoid these operations where possible, if you have any expectations of performance.

                - these operations are in place mainly for expressiveness in code, not for
                  performance.

                - this may improve in the future, but for now, avoid where it matters.

        * added sqr and sqrt as unary operators

        * added field deref on array elements (lhs+rhs), i.e. a[i].f=a[j].f
            * will only support one level of this (i.e. no multiple [] or . on lhs)

        * removed deval() test function.

        * breaking change - separated interpolation into {...} for var substitution and {=...} for evaluation.
            * if you need to read a global variable in substitution now, you should eval {=...} instead.
                ( or read the variable locally and substitute as normal )

            * the reason for the change was to permit such things as =| awk '{print $0}'
                to work without the evaluator thinking you were trying to use a statement (PRINT)
                as an identifier during eval.

            * you could also have turned interpolation off temporarily around the command, but this
                then meant you could not perform a secondary sub in the same command, e.g.
                    a =| awk '{print $0}' <{file}
                    # {file} would be ignored.


        * breaking change - removed ZERO, INC and DEC statements.
            * these were becoming more troublesome than they were worth to maintain.
            * ZERO was already effectively replaced with the more flexible VAR statement.
            * commands replaced in eg/ code.

        * added pre- and post-fix decrement and increment for numeric types ( (u)int(64),float64,uint8 )
            * needs more testing
                * added a bodge to the parser to keep hold of the previous token
                ( added another one for the pre-previous token too, for the compound assignment ops )
                    - not how it's supposed to be done, hence more testing. 
                    - we only keep the accumulated left-hand value not the token normally.
                    - bodge should allow us to add -=, +=, /=, *= and %= fairly easily now.

        * fixed tail-call elimination (hopefully!) after the changes for multiple return 
            values broke it. needs some more testing, but appears to be correct.


1.0.10  new evaluator, bug fixes and documentation updates

    * New evaluator written for some small speed up and better integration with whole.
        * features will be detailed below. It is about 95% feature complete, I think.
        * existing programs should run fine, but there may be a few details I've overlooked...

        * re-uses existing token streams (except in interpolated sub expressions)
            * pre-1.0.10 we were re-tokenising from input string (mostly changed now to token streams)

        * error capture - need to pass these back up to .Eval()/deval() uniformly
            * done quite a lot of this - maybe a few small things outstanding.

        * new evaluations from a given functionspace should re-use a parser instantiated at the
            start of the function Call().
            * the parser is passed through sub eval routines which require it.
            * this saves on initialising the led/nud map repeatedly in many cases.
                * will probably still happen in recursion,
                * definitely will happen in interpolation and user eval() calls.
                * need to work around the interpolation one definitely. i'm probably missing a trick here.
                    * DONE, maybe? Added a separate parser instance just for the interpolation routine,
                        and threw a mutex around it. should be good enough.

        * initially only supported basic arithmetic (-+*/%). But, we have now added:

            * float support
            * equality operators (==, !=, >, <, <=, >=)
                * float comparison gets fuzzy around the 16th decimal place
            * power (**) operator.

            * logical operators: negation ! , bool && and ||
            * decimal shifts: shift left and right operators: << >> 

            * string literal support
            * array literals: [ x,y,z ]

            * identifiers: needs more testing but pulling sane values and types from scope so far.
                * identifiers cannot be named the same as reserved keywords (and it doesn't crash now!)
                * identifiers can share names with library functions or user-defined functions.

            * bit-wise operators: ^ (xor), & (and) and | (or)
            * booleans: added true and false constants. some testing done. seems okay.

            * user-defined function integration
            * standard library integration
                * for both of these, there still may be some clean up to do in order to reduce the 
                    number of chained function calls these pass through. (ev/udf/Call/interpolate/buildRhs/etc)

            * getglob() is now optional!
                * globals are now checked for a match *after* local var names have been checked.
                * The SETGLOB keyword is still mandatory. (and will probably remain so, and not for technical reasons)

        * performance: the new evaluator started with terrible performance, as most things I write tend to do :)
            * the old evaluator (1.0.9 and below) was around 12-13 times slower than python on same machine
            * the new evaluator started life around 4-5 times slower than python.
            * we are now at around half the speed of python evaluation after a little tweaking.
                * we will continue to tinker with this between releases, but expect it to get steadily faster.
                * i will run out of ideas eventually (probably not far from now) on how to improve it, but 
                    the basic issues are avoiding mem allocations, avoiding defers, avoiding mutexes (to a small degree),
                     avoiding maps, using smaller datatypes, avoiding even array lookups, cutting out function call chains,
                     inlining more of the smaller things, forcing things on to the internal stack, etc, etc.

                * better integration of pre-1.0.10 features should also improve speed.

                * i'll keep chipping away at it :)

            ****************************************************************************************************************
            * currently best performance comes from using fixed arrays where you can (with INIT) and avoiding interpolation.
            ****************************************************************************************************************

            associative array performance is acceptable, but things like map writes are still about half the speed of python.

            * for tight loops that only require a simple addition / subtraction it is still much faster to use the INC/DEC statements.
                * INC and DEC are slightly faster than python in the same tests (eg/addition_loop and eg/alt_lang/addition_loop.py)

        * in all honesty, further performance gains are entirely optional at this point, and quite unnecessary. We'll do what
            we can with little effort involved, but it is now quite fast enough for the intended use cases, i.e. shuffling data around
            in simple scripts that replace bash/perl/awk monstrosities.

        * Performance difference between 1.0.9 and 1.0.10:

            Measures below from FreeBSD. Ubuntu has similar gains. Windows/Alpine/others not checked yet.

                                v1.0.9      v1.0.10
            eg/long_loop        1.71s       1.2s        ( 100 million iterations, avg 3 runs )
            eg/addition_loop    61.0s       15.1s       ( 40 million iterations, avg 3 runs )
            eg/map_writes       55s         11s         ( 20 million iterations, avg 3 runs )


    * Added language version comparison in REQUIRE command. 

        usage: REQUIRE x.y.z

        Compares the required semantic version to the version of the interpreter currently executing. Bails out with an error
          if x.y.z is greater than the executing version.


    * Added command VAR: (experimental)

        * var is used for declaring an "expected" type.
            It is not enforced completely, it is more for additional sanity checking.
        
        * as an example:

            var i bool      # i=false
            var j int       # j=0
            var k string    # k=""
            var l float     # l=0.0
            var m uint      # m=0

            i=42

         ... will produce a run-time error at "i=42" and execution will stop with an appropriate error.

        * the underlying storage type will be set to the appropriate type (instead of untyped)
            and the internal vset() function enforces it.

        * if you try to VAR an existing variable name in the same function scope you will 
            also get a run-time error. E.g.:

            i=42
            var i int # or whatever else
            # results in error

        * permitted expected types are: int (64 bit), int64, bool, float (64 bit), string, uint (64 bit)

        * you can still continue to use untyped variables without the declaration as before.

        * this is not meant to be a full type system, it is only intended to help with 
            basic checking. the scope may be extended further to help in other areas, but
            most likely you'll never use this :)

            * we'll expand this into compound or other data types later if there's justification to do so,
                I'm just not sure how useful it will be yet.

        * another reason for this is that some library functions may be able to perform better if 
            they understand the argument types ahead of time.


1.0.9

    * BSD preliminary build:
        * cloned console_*, winch_* and lib-os_* to freebsd versions.
        * amended console_freebsd with TCGETS/TCSETS replacement values: TIOCGETA+TIOCSETA
        * amended build and build module with freebsd specific options (removed upx)
    	* THIS IS A TEST BUILD. IT RUNS, BUT A FAIR NUMBER OF THINGS MAY STILL BROKEN.
            * eg/flood displayed zero hitching due to the OS. performs better than linux in this regard.
        * moved TC[SG]ETS and TIOC[SG]ETA to separate const files:
            : console_const_linux.go+console_const_freebsd.go
            : moved console_linux.go to console_unix.go
            : removed console_freebsd.go

    * added -Q option for reporting specified coproc/shell command options.
    * fix shell detection on startup for freebsd: anomaly - was missing a @last default set
        in Copper()/console_common.go

    * test web server functionality in freebsd:
        * was fine with some changes to the eg/web example for static hostname.

    * check concurrency is working as expected for dynamic pages in web server (in freebsd):
        + siege : siege -b -c 100 -r 100 -k http://127.0.0.1:8080/fun/awsip
        * siege worked fine for lower numbers than above. would have been fine with higher
            except that the example page has a link to unpkg.com for pure CSS and this and
            DNS lookups hit rate limitations upstream. 
            Lower numbers for -c and -r were fine (once throttles dropped away between tests)
        * siege was perfect with the above (or higher) -c and -r when fetching the static
            example @ http://127.0.0.1:8080/exmachina/index.html.

    * because of the changes in this version, general release will be delayed for more clean-
        up and testing. i felt bsd support + structs were important enough to allow this.

    * added sequential/random access filing functions:
        * new funcs: fopen, fclose, fseek, feof, fread, fwrite
            * see the library html pages for details.

    * eval lib updated (accessField processing and add/sum/mul/div/unaryminus/mod to
        handle other signed int types.

    * added unary positive and improved lexing a little on scientific notation NumericLiteral cases.

    * removed a few more allocations in FOR..ENDFOR.
    * replaced a vset() call for direct var access when thread safety not required, in ENDFOR.

    * started work on STRUCT struct_name...ENDSTRUCT and INIT var struct_name
        * syntax in place.
        * added STRUCT and ENDSTRUCT to vim syntax file and online doc.
        * struct builder done. (actor.go, added struct, endstruct and structmode)
        * added SHOWSTRUCT [filter] command for listing structmaps.
        * INIT changes done. (init var_name struct_type)
        * struct comparisons:
            * == and != should be fine for shallow comparisons.
                * as we don't allow nesting, this should be enough for now.
            * >, <, >=, <= make no sense between structs and therefore generate an error.
        * eval.go/dotted assignment changes done.
            * added a check for field name's existence pre-assign.
            * added a type check for assignability.
            * added more error handling around various outcomes of struct field assignment.

        |
        | example:
        |
        | struct s_person
        |   name    string
        |   age     int
        |   dob     string
        | endstruct
        |
        | init person s_person
        |
        | person.name="billy bramble"
        |
        | define showBirthOf(p)
        |    print p.dob
        | enddef
        | showBirthOf(person)
        |
        | etc, etc....


        * struct definitions are available throughout all scopes.
        * struct instantiations are locally scoped.
        * only some basic types are supported for fields:
            * bool, int, float64, string
            * int32, int64 and uint64 should also be supported, but need more testing.

        * i am very unlikely to add more complex types as field types (arrays/maps/etc).
            * the intention here is for structs to be used for bundling config and improving stdlib options.
            * for this, we do not need anything more complicated. will see how it goes though...

        * the structs are formed with compatibility in mind to the underlying Go language.
            * this will allow for their use in the Za stdlib and a few other hard to reach places.
            * unlike Go, there is no enforcement of private/public capitalisation of field names.
                * that is, all fields are available regardless of casing, within Za.

        * structs should also allow for some slightly cleaner passing around of bunches of config. 

        * serialise and deserialise struct to string/json/something for save/load:
            * new lib calls: write_struct(file,source_struct_name) and read_struct(file,dest_struct_name)
                * these functions take a flat struct variable and send them to or from disk.
                * read_struct requires a reference struct as a template for populating the return value.
                    * the usual process would be to define a struct, initialise a var as that struct type
                        then use the empty initialised var as the destination struct which read_struct will
                        populate after examining the layout. 

        * some vague examples here: eg/struct, eg/struct[23], eg/struct-serial


        !!                                                                          !!
        !!  there are quite likely a ton of bugs with struct handling currently     !!
        !!  USE WITH CAUTION                                                        !!
        !!                                                                          !!


    * STRUCT parsing limitations:

        * dereferencing: array of struct

            * it is possible to declare an array as mixed type, eg:
                | init a mixed 10
            * and to then assign a struct value into an array element:
                | init b s_person
                | b.name="test"; b.age=10
                | a[0]=b
                | print kind(a[0])
                >  struct { name string; age int; dob string }

            * if you assign a 'blank' (initialised, but no fields assigned to) struct value to an array element,
                then unspecified behaviour occurs. generally, the array element will assume the type and zero value
                of one of the struct fields of the whole struct assigned to it. populate the struct before assignment
                to the array element! (at least partially)
    
            * you can access fields directly, eg:
                | print a[0].name
            * or retrieve an entire struct record:
                | c=a[0]

        * it is currently not possible to mix dotting and arrays in assignments.

            * to operate on elements of a field, you must pass the object or the field through temporary vars, eg:
                | c=a[0]
                | c.name="new_name"
                | d=c.name
                | print d[2] # 'w'
                | a[0]=c
                | print a[0].name       # 'new_name'

            * you cannot directly access elements of a dotted array element, eg:
                | print c.name[0]       # error
                | print a[0].name[0]    # error

        * as usual, I cannot improve much upon this without rewriting the parser and evaluator "properly".

        * the situation is similar for associative arrays:

            | struct S; a int; b bool; endstruct ; showstruct
            > S
                                   a int
                                   b bool

            | init a S
            | m["first"]=a
            | print kind(m["first"])
            > struct { a int; b bool }
            
            | for e=1 to 5; m[rand(10000)]=a; endfor; print m
            > map[1319:{0 false} 1848:{0 false} 2082:{0 false} 2541:{0 false} 3301:{0 false}]

            | print m[1848].a
            > 0
            | print m[1848].b
            > false

    * added write_struct and read_struct lib calls. (to/from disk)
    * added uint lib call (for type conversion)

    * more doc cleanup

    * moved interface{} type cases to end of switches.
        * fixed error in reverse() lib call due to the new placements. (type assertion error 
            revealed in previously uncalled code).
        * fixed a bad append() in eg/mon (int to []float)

    * console_windows consolidation review
        * split common functionality with console_linux to console_common.go
        * still a couple of other funcs that could be broken up, but okay with those for now.

    * added terminal object nil check in term_complete()

    * added expand_aliases and -i to bash startups. 
            it still won't pull a startup file in, but at least the alias command
             will work again for new aliases.

    * fixed bug in non-shell interactive mode exec calls.

    * added existence and empty checks in INPUT id ENV var command.
        * the Za id variable is left intact when env var is empty.
        * if Za id variable didn't exist then it is created regardless of env var existence.


---------------------------------------------------------------------------------------------
1.0.8

    * added ctrl-c handler in keypress() func. sig_int is now raised when detected, but keypress
        still returns as normal. this allows a user interrupt handler to still be defined, or
        for the interruption to be ignored and the ctrl-c (dec:3) to be captured in keypress().

    * after testing with sh/dash/ash and similar, found the echo -e required in coproc calls was
        problematic. (didn't interpret escape codes too well).

        * added check for custom shell basename of sh, ash or dash. when this occurs, then external
            printf command is used instead (/bin/printf).
            * will try and come up with a better workaround later.

        * no extra system variables output that are sh/ash/dash specific yet.

    * zsh seems fine still, except for only putting out a single zsh specific sysvar. will work 
        on more of them later.

    * will deal with WSL/mingw/windows'y things later.

    * fixed repeated enter key glitches in interactive mode. (was more slow ANSI VT response issues).

    * added check for terminal availability and ready-to-send status in GetCursorPos(). 
        * mainly added for docker compatibility when not using -it in exec/run.

    * added some more functionality around handling "all interfaces" 0.0.0.0 web service requests.
        * http.ListenAndServe now split in half and tcp4 request servicing enforced.
        * removed the enforced 404 return when hostname/ip not found in web rules
            * instead a secondary check is done when the request host name not found for rules
                which contain 0.0.0.0:reqPort instead.
        * these changes were done to allow the web server to be used more successfully from
            inside docker containers.

    * added getcores() to retrieve cpu core count.

---------------------------------------------------------------------------------------------
1.0.7

    * console: key repeat was not behaving. holding down key caused glitches.
        * GetCursorPos() call (ANSI VT code call+response) was a little slow anyway
            and opening and closing tty constantly was getting to be bad news.
        * now keeping a handle throughout execution for dev/tty
            * update: now tested, seems okay. *tentatively backs away slowly from the scene of the crime.*

        * still a small issue with repeated ENTER presses. cursor is jumping about. nothing
          urgent to fix though - cosmetic.

    * added date functions:
        * time_hours,time_minutes,time_seconds,time_nanos,time_dow,time_dom,time_month,time_year

    * interactive mode:
        * cosmetic fixes in console_linux.go/getInput(). 
            stopped colour codes and percent signs wreaking havoc.

    * some more examples in function docs.

    * renamed deq to pop
    * renamed push to push_front
    * append() already does what push(_back) should have
    * added peek() -> returns ary[len(ary-1]

    * libdoc: updated stdlib help descriptions some more.
        still some way to go on this particular labour of hercules.

    * added stdlib tests: db, net

    * added -U startup option
        this option is for specifying the byte to be used for signalling end-of-output
            of a co-process command.
        By default, this is 0x1e (31)
        If this may clash with something in your environment, you should specify an alternative
        with the -U option.


---------------------------------------------------------------------------------------------
1.0.6

    * clean up of source layout and use of modules.
        * if compiling from Go version 1.11/1.12 then source GO script before first build.
        * this excludes changing the goval code, it's far too entwined now.
        * added go.mod/.sum for other modules, internal archiving updated to exclude the cache

        * will monitor for problems, before opening up the github repository.
            * will also probably need a rebase/cleanup of old version code.

    * added: int=next_match(s,regex,start_line) # to return matching line number (0 based)

    * interactive mode
        * added a little more sanity to multiline input on bottom terminal window line and
            at line endings.
            * fairly sure it will still be broken in a multitude of ways.
                ( such as navigating multiline history )

---------------------------------------------------------------------------------------------
1.0.5

    features:

        * added stripansi() lib call.
        * added addansi() lib call.
        * added uninstall() lib call. *experimental, not tested in all OS yet*

        * added download() lib call in lib-net. Like web_download() but auto names and 
            provides console feedback.

        * added func_categories, func_inputs, func_outputs, func_descriptions lib calls.
            * these are to support doc generation. probably no use for anything else.

    fixes:

        * added an inline'able strcmp (internal fn) to use in hot spots instead of built-in
            string equality. this speeds up inc/dec and interpolation somewhat.

        * added up-scaler to loop allocator

        * fixed issue with calltable id allocator not reserving instances before async tasks
            swamped it. new allocation requests now have faked allocation slot info on 
            exit from GetNextFnSpace().

        * amended calltable id allocator to loop while req_ifs>cap as async
            allocations were busting it a new asshole. (instead of only allocating once)

        * added deallocator to calltable[] actor.go/GetNextFnSpace(). 
        * added deallocator to loops[] in actor.go/Call()

        * updated help descriptions for library calls.
        * updated arg names in library call help.

        * added check on user-define funcs for names clashing with stdlib funcs

    misc:

        * added eg/tests/libcov for vaguely checking library test coverage.

        * function reference
            * auto-generating now with libdoc tool. still needs some work. 
            * za-ref.html now contains a link back to zalang.org/funpages/index.html instead
                of maintaining two lots of fn descs.
            * libdoc is executing during "docpull" run.
            * example pages can be created by hand and placed in a prepared location for 
                inclusion in the final page output.

---------------------------------------------------------------------------------------------
1.0.4

    fixes:
        * found another read lock race cond in lib-net. fixed.
        * updated source comments
        * updated error reports and help texts
        * removed more dead code
        * removed a Call() parameter left over from separate call modes. 
            * this should speed up recursion considerably. It was passing an empty struct in.
                * it's still slow, just not as much :)
        * changed actor.go/inbound to use pointers instead of copying phrase from source.
            * again, there's another small speed bump in places due to this.
        * re-enabled some eval.go/ev() error capture.
        * expanded sort() functionality a little
        * added a few more of the missing iteration types in FOREACH
        * added argument 2 in funcs() to return (true) or display (false:default) the results.
        * updated help text
        * bah, had to tinker more with interpolation. was throwing errors in the background 
            when it should have been ignoring unevaluable contents of curly braces.
                * added shouldError param to ev() and interpolate()
            @note-to-self: don't go back in that code for a few weeks, give yourself a chance to heal.
        * updated (all?) functions in lib-list and lib-string to check OS and determine correct EOL
            * this is mainly for splitting and rejoining strings/arrays correctly on both Linux and Windows
                * chances are I missed a few :) linux has been tested, but not exhaustively on windows yet.
        * updated build script (cosmetic)
        * changed calltable to scale up dynamically
        * fixed remaining issue in fields/field calls for CRLF
        * updated eg/mon.
        * changed call format and allocation method for new functions then had another disagreement with concurrency.
            * fixed the leaky dinghy and all seems well again when testing web servers.
        * added some more error checking in lib-string (trim, start and end)
        * more bug squishing in lib-string.
        * some more fiddling with lex.go after changes to eval.go, brace nesting and array assignment.
        * changed keypress() to encode  symbols as decimal 163. although we don't support utf8 input or extended
            ascii in any meaningful way, we still needed to distinguish  from # on key capture.
        * updated za.vim for WITH...ENDWITH and tco+echo+unmap+getcol+getrow
        * added capture of current text cursor position on startup in non-interactive mode. this was to ensure the PROMPT
            command uses the last cursor position *or* a position set by AT statement.
        * updated key and globkey to avoid a type exception in arguments.
        * added search-by-category back to the funcs() call. (as well as by function name).
        * added pass through of the current function id to the expression evaluator to get rid of another
            global that was always screwing with multi-threading (lastfs var).

    features:

        * modified the build script to produce a cut-down windows version

            * ansi colour support is automatically disabled on windows
                * it can be re-enabled with either -C flag or ansi(true) at run-time

            * the interactive mode is probably a bit crippled
                * getch(), wrappedGetch() have been reworked, but interactive mode will only work
                    if you use a VT-capable terminal, such as ConEmu.

            * added a timeout capability to the Windows keypress() version.

            * the co-process is disabled
            * console resize signalling (SIGWINCH) is disabled

            * i don't have any burning ambition to get this working fully, but the executable
                works given the caveats above. Getting those things working is an incredibly 
                low priority for me... possibly never.

            * to build: ./build win (generates za.exe, copy it where you want it).

        * added -C flag (force ANSI colour on)
        * added ansi(bool) to enable/disable ANSI colours support at run-time.
        * added separate handler for executing windows commands in | and =|
            * uses "cmd /c {command}" 
            * may add some support for varying the command interpreter and options later.
        * added windows detection in col() for CRLF splits.
        * updated term_h() and term_w() to fetch approximately correct terminal dimensions on windows
            * possibly depends on the console in use, not tested many yet.
        * you can now wrap up | and =| command call text in backticks (`cmd`) to allow semi-colons in command.
        * added system(str[,bool]) for executing a more constructed system call. display output when bool is true.
        * added dir() lib function. dir(path[,filter]). returns a list of directory entries as an assoc array.
            * each entry consists of these keys: "name", "size", "mode", "mtime", "isdir" 

        * added a check in ASSERT to warn if an assignment is present.  
            * For example, the following would cause a fatal exit:
                ASSERT strpos(t,"we ",0)=0

        * added: WITH id AS f ; ... ; ENDWITH construct

            * !!! may still have some issues !!!
                * leaking some temp files on exit still

            * this will be the equivalent of:
                f=|mktemp; write_file(f,id); ... ; rm -f {f}; unset f
            * on exit (of any type) it has to clean up the temp file(s).
            * filename should be available inside ... part.

                as an example, it will turn this:

                    f=|mktemp
                    write_file(f,s)
                    ac =| awk 'END{print NR}' {f}
                    wc =| wc -l {f} | cut -f1 -d" "
                    | rm -f {f}

                into this:

                    with s as file
                        ac =| awk 'END{print NR}' {file}
                        wc =| wc -l {file} | cut -f1 -d" "
                    endwith

        * added: html_escape(s) and html_unescape(s) lib calls.
        * added: delete(f), rename(sf,df) and copy(sf,df) lib calls.
        * added: bool(s) for converting string to bool type.
        * added: umask(int), chroot(string), cwd() and cd(string) lib calls.

            * was going to add some setsid/setuid/setgid variants but it looks like they are not going to
                play well with either Go's concurrency or future compatibility as they have been left to
                rot in the syscall package. Probably just as well - think they may have turned ugly later :)

        * added: eg/args for processing CLI args.
        * added: eg/strings tests for string library.

        * started work on tail call optimization

            * in the first instance (and probably the only one!) we have added some simple tail recursion 
               elimination on return statements

                Under these conditions the function will be re-used:
                    1. executing a RETURN statement, and,
                    2. there is a function call to the same function name already executing, and
                    3. the function has parameters, and
                    4. there are no other subsequent parts to the return expression than the function call.

                If these conditions are met, then various counters are reset, and each argument in the return
                 expressions are evaluated and their results stored in the variables defined as input parameters
                 for the current function. Subsequently execution jumps back to immediately before the point
                 at which the first line of code of the function is executed.

                This has had a massive impact on certain forms of recursive function. Please see the examples
                eg/fib.nomemo and eg/fib.tailrec for comparison.

                Obviously, you still have to write recursive functions in a manner which takes advantage of this.
                 It's still interpreted, after all!

            * added: tco() library call, to check if the current function is in a TCE loop. This is useful for 
                keeping counters in benchmarks.

        * added: echo(bool[,string]) lib func. Enable (true), disable (false) or return the status (no arg) of local console echo. 
            * if second option provided, it sets the character mask for hidden input with PROMPT command.

        * added: getrow() and getcol() call in library to use GetCursorPos() func. 
        * added: (internal) GetCursorPos() equivalent for Windows.
        * added: unmap(a,k) to remove a map key 'k' from array 'a'

        * asynchronous calls:

            * new statement ASYNC
                * usage: ASYNC handle_map f(...) [key_name]
                    * ASYNC will run function f() in the background, with given arguments (...)
                    * handle_map is the name you wish to give to ASYNC as a storage list into which a handle is placed
                        for the asynchronous task.
                    * key_name is an override for the handle id in handle-map.

                * if a handle_id exists in handle_map then you should assume it is still running. 
                    * it may have completed, but you won't know until you next poll for results with await()

            * new standard library call: await()
                * usage: results=await(handle_map,wait_flag)
                    * await will poll for results returned by tasks launched by ASYNC.
                    * You must provide the handle_map into which the async task was handed-off.
                    * When the function provides a return value, it is placed into results[handle_id]
                    * If a wait_flag is provided, then await() will either wait indefinitely for all functions in
                        handle_map to complete execution (flag:true) or will just poll each in handle_map for completion
                        whilst populating the results list, but return to the caller immediately upon check completion.
                    * as a task completes, await() will remove the handle_id from the handle_map.
                
            * example case:

                # some background task
                define f(z)
                    pause rand(3000)
                    return z*2
                enddef

                # launch all in parallel
                for x=0 to 99
                    async hndmap f(x) x
                endfor

                # collect results
                res=await(hndmap,true)
                for e=0 to 99
                    println "{e} -> {res[e]}"
                    assert res[e]/2 == e
                endfor


            * if you do not care about the order of the returned results, you can skip adding a key_name in the async statement.
                * a unique key is generated in these circumstances, i.e. "async_f@39495943999" or similar. 

            * if you plan to use async with functions including shell interaction then you should use the -S option at launch.
                * attempts to run shell commands in parallel may otherwise return interleaved results and assorted other
                    unpredictable behaviour.
                * we can probably fix this with a command queue, but there are no plans for that currently.

            * it would probably also be wise to use the -l option (or the locks(true) call at runtime) to ensure that all mutex
                locking is enabled, for the same reason. this should not be necessary, but this is a new feature after all!

        * added: coproc(bool) call. This is to enable processing of | and =| statements using either the co-process shell (true) 
            or the current execution pid's shell (false). This was added so that async command calls could be safely processed.
            On windows, by default, execution is in the current process rather than the child shell (as we use 'cmd /c' calls
            currently on windows.)


1.0.3

    features:

    * added json_decode() to convert string to mixed map
    * added json_format() to indent a json string

    note:
        this is only a roughing out of json support. we only really need to be able to read and process json files at a minimum.
        example use:

            # get json file
            str=read_file("eg/test.json")

            # convert to mixed type map
            print json_decode(str)
            map[bugs_collection_link:http://api.launchpad.dev/beta/bugs people_collection_link:http://api.launchpad.dev/beta/people]

            # format original string
            print json_format(str)
            {
	            "people_collection_link": "http:\/\/api.launchpad.dev\/beta\/people",
	            "bugs_collection_link": "http:\/\/api.launchpad.dev\/beta\/bugs"
            }

            # pick out value
            b=json_decode(str)
            print b["people_collection_link"]
            http://api.launchpad.dev/beta/people

            # process
            foreach e in b
                print format("%v (%v) %v",key_e,kind(key_e),e)
            endfor
            people_collection_link (string) http://api.launchpad.dev/beta/people
            bugs_collection_link (string) http://api.launchpad.dev/beta/bugs

    * added (test) support for shell-less executions.
        if the -s arg is set to /bin/false, then any | or =| commands are routed through the shell of 
            the za instance parent, rather than a child process.
        last() and last_out() are still supported, but more limited in stderr output.
        may give this it's own cli opt arg later.
        N.B. using in this fashion though you lose variable and env persistence between commands.

    * added -S CLI argument for disabling the co-process shell entirely.
    * added has_shell() to lib-internal.
    * added abs() to lib-math. 
        * this gets inaccurate for floats, e.g.
            > print abs(-2.30000000000000001)
            2.3
            > print abs(-2.3000000000000001)
            2.3000000000000003
        * int uses a different calc. float is using the Go math.Abs fn.

    * added globlen() to lib-internal.
        * this returns the length of a variable from global scope or -1 on error.
            * @bug: if an array or map is expressed as, for example,  "a[]" instead of "a"
                then the string length (3 in this case) is returned, but without error. don't do this! :)
                * this will eventually be treated as an error.
            * @note: the length of an array is the same as it's currently allocated cap, e.g.
                > init q int 10
                > print len(q)
                10
                > print q
                [ 0 0 0 0 0 0 0 0 0 0 ]
                > q[11]=42
                > print len(q)
                20
                > print q
                [ 0 0 0 0 0 0 0 0 0 0 42 0 0 0 0 0 0 0 0 0 ]
            * due to the above, should you need a measurable length array, please use an associative array, e.g.
                > z[11]=42
                > print globlen(z)
                1
            * this applies to both len() and globlen() functions.
                * currently debating if this should be adjusted. probably not going to though.
                    it isn't difficult to keep track of what you are using in a pseudo fixed length array.
                    we only allow the automatic length adjustment to save redimensioning in code.
                    if it becomes enough of a problem for people, we can adjust it.

    * examples changes:
        * added basic colour test: eg/colours
        * amended eg/ascii
        * added eg/json. the script shows depth processing and colouring of json content.
        * updated za-ref.html->stdlib list

    fixes:

        * stripped trailing \n in parse()
        * moved locking on lastline global into report() function
        * tweaked error reporting inside ev(). was throwing false errors during interpolation.
        * stripped out sys var 'path'. not used by anything.
        * changed sys var 'pwd' to retrieve from /proc link instead of issuing coproc command.
        * endfor without for/foreach inf. loop : added lastConstruct check at depth[ifs]
        * when: silent fail without condition : added check+error message
        * when: can contain code before first clause
            not fixing. consider it a present :)
            will pull this if it becomes a problem.
        * pane: define - error msg cleanup : removed some debug info
        * exit <expr> - invalid expr causes exception : fixed missing 'ef' eval fault on var check in wrappedEval()
        * return: returning from global/main? not setting exit code
            added check for functionspace reference and now passing exit code out on exit.

        * removed some of the mutex locking, re-arranged the rest. still not perfect, but -race not breaking now.
            tested with eg/web server. only failures due to req. rate, not concurrency failures.

        * updated actor.go/C_SetGlob to accept `lhs "=" rhs` instead of only `lhs rhs`.
            memoizing ackermann test was breaking on interpolated elements including a comma between dimensions.
            this worked fine using other separators. need to update all setglobs and manual to "=" version.

        * amended dump() to not display read-only system variables
        * changed some sys vars to read-only naming
        * added a shellpid() lib call for getting the pid of the co-process.

        * fixed initialisation of var in inc/dec for not existing var names.

1.0.2 fixes:

        1. added general support for array types in interpolate(). whole arrays and any simple type should
            now be converted during interpolation.  Array elements are still considered out-of-scope for 
            conversion and should continue to be resolved in the usual manner outside of interpolation.

        2. added a default conversion in interpolation that also displays the type when caught.

        3. removed single trailing newline character from results of line_filter(). (was added by loop in same fn)
            may need to remove wrapping collapse() calls that previously corrected this.

            * there is a chance this will break previous functionality, but probably not         *
            * in almost all cases this new line removal will have been taken care of post call.  *
            * it was always an unwanted artifact.                                                *

        4. added new function: interpol(bool). This enables or disables string interpolation.

        5. added basic handling of array elements and evaluation inside of interpolation phrases. 
            needed to add a conversion of array elements in interpolation. was able to cover calcs and other eval at same time.
    
            This kind of thing should now be possible:

              a="10"; b=20; c["x"]="bang!"
              println "{a} {rand(20)} {c[`x`]} {b} {pi()+10}"

              output example:
              10 8 bang! 20 13.141592653589793

            Use with caution for now - test feature. Mixing ` and " badly will definitely result in unexpected behaviour.
            It probably has bounds issues too. Still under review!

        6. changed ON..DO to re-enter inside function rather than re-call fn in different mode. 
            removed CALL vs ENACT mode. we instead build a phrase and inject it at ondo_reenter.
        
        7. stripped part of the old multi return value code, replaced with simplified version.

        8. changed function startups to reuse space for variable sets (functionspaces) or loop counters if previously allocated.
            this was to speed up recursive calls a bit. took fib(30) down from ~ 1m40s to 0m38s. fib(20) down to below 1s.
            new eg/fib example shows how to speed it up much more: fibonacci(92) is approx 0.04 seconds memoizing.

        9. fixed a broken empty lexed string case in lexer.go... wasn't returning properly.

       10. i may have forgotten to add a couple of ampersands here and there.. nowhere important, just on a few of the 
            mutex locks. nothing to see here - move along!

       11. retested with -race and pprof. couple of small edge cases when stress testing the web server concurrency.
            i guess this is to be expected to some degree, but its more stable now. it was already okay. i'll eventually nail them all.

       12. updated examples: eg/web. new example: eg/fib (memoizing recursive)
             recursion is still slow, especially mutual recursion. need to clean up func calling method before this will change.
             as usual, not a priority. use a real language if you want to do this kind of thing :)


1.0.1 fixes:

        1. added type checks to fields 3+4 of fieldsort()
        2. added some support for array/map element literals in INC/DEC - needs similar in ZERO.
            support not yet in for variable/expression in INC/DEC/ZERO of array/map elements.
            messy, but same can be accomplished with normal assignments for now.
            definitely no support for interpolation in INC/DEC/ZERO currently.

            probably best currently to avoid these keywords if speed is not a concern!

            they are fine for their original purpose of simple counters, but would be best if they
            went away entirely. a faster evaluator would allow for that.
 
1.0.0 pre-release version - documentation/file structure changes

---------------------------------------------------------------------------------------------

0.9.6 feature freeze - only bug fixes

        1. subscript out of range (negative) - process crash
            - added a check in actor.go/C_SetGlob, eval.go/wrappedEval() and goval_parserUtils.go/accessField().


0.9.5 feature freeze - only bug fixing before 1.0

      fixes:

        1. added // comments back in.
        2. fixed # and // comments at end of statements.
        3. removed EOL and comments from processed source.
        4. removed the handling for eol/comments in main call loop. speed increase of ~25mips on ref machine.
        5. did the same as 3. for empty lines. ~10mips inc on ref machine.
        6. small refactor inside actor.go/C_Endfor and related routines to waste a few less cycles.
        7. in lex.go and parser.go: removed dead assignments and duplicate length checks. 
                removed length checks from loops - not as bad as it sounds!
        8. added type (string) enforcing for arg #1 in format()
        9. removed semi-colon tokens from processed source.
       10. more type checking in lib-convert.
       11. additional checks in float().
       12. fixed problem in eg/mon (unstripped newline in input field)
       13. added 'e' error redirect support to local server in web_serve_*().
       14. added missing arguments parsing to user sigint handler.
       15. fixed typos in lib-html on some tag end strings.
       16. fixed missing GET/POST query+fragment passing to "s"


0.9.4 no more than 1 new feature
      no progress without 3 bug fixes.

      features:

        1. added a user interrupt (ctrl-c) handler:

            when global variable trapInt is set to the name of a Za function,
            that function will be called at the end of normal ctrl-c handling.
            if the function returns a non-zero value then a hard exit is made from Za with
            the specified return value as the exit code.
            Otherwise Za will continue with its usual behaviour on return. This may include
            a program exit in non-interactive mode or continued operation, in interactive mode.
            If no return value is provided then operation continues without user or system interrupt.

            e.g.

            <snippet>
            define test(msg,exCode)
                println "user handler!\n{msg}"
                return exCode
            enddef

            trapInt = "test(status,code)"

            status="current break message."
            code=127
            </snippet>

            If ctrl-c occurs now, then output is...

            user handler!
            current break message.

            echo $?
            127

      fixes:

        1. vcmp()/service()/install() had an arg data type fatal crash. resolved.
        2. renamed cursorOff|On|X to cursoroff|on|x.
        3. some optimisation required in while..endwhile, too slow vs FOR

            a) added a cache in ev() to avoid rebuilding the token string for eval if same as previous.
                tested with multithreaded web server and no issues exhibited.
               this took eg/countdown (while test) from ~2922ns/it to ~1910ns/it. (+180K it/sec)

                its/sec        342.137 Thousand
                its/sec        523.493 Thousand

            b) added a last string cache in goval_lexer.go/NewLexer() to avoid FileSet/new allocation of token.File.
                eg/countdown went from 1910ns/it to 1583ns/it. (+110K it/sec)

                its/sec        631.636 Thousand
                
               currently disabled when lockSafety is true as it doesn't play nicely with concurrency. 
                Needs lastlock mutex around laststr and lastfile to avoid this.
                However, this would probably negate the benefits of caching.

               this is right on the edge on what is left to gain from the current math evaluator. it needs rewriting at this point.


0.9.3 no more than 2 new features
      no progress without 3 bug fixes.

      features:

        1. added a "topline" box format. split lr into tlr + blr in box().
        2. shuffled a few bool checks around in actor.go / Call() main loop to speed up processing.

      fixes:

        1. amended pad() to ignore colour codes.
        2. fixed eg/mon output formatting.
        3. blocked co-process calls ending with | or only consisting of | and <space>.
        4. when *any* indirection present inside a loop, then always update the loop counter.
            This is to avoid missing an indirect reference to the loop counter, without having to trace each
             and every interpolation. We are just erring on the side of caution here.


0.9.2 no more than 3 new features
      no progress without 3 bug fixes.

      features:

        1. added: strpos(s,sub,start) for finding next match in a string.
        2. added: example eg/stddev for calculating sample standard deviation with lists
        3. added: argv() function.

      fixes:

        1. added trim and tr(squeeze) to collapse().
        2. removed todo: add a report to PANE without arguments.
        3. commented out quote stripper in actor.go/C_Return. Checking if it is still required.
        4. removed some already done @todo notes.
        5. changed argc/argv to include arg #1 if in interactive mode or processing a -e string.

0.9.1 no more than 4 new features
      no progress without 3 bug fixes.

      features:
        1. added split, join and collapse functions.
            split will convert string to list. join converts list to string.  collapse converts NL to space.
        2. added line_head and line_tail (nl-separated string, simple head/tail w/count. nothing fancy.)


      fixes:
        1. changed exit iterator value from FOR/FOREACH w/ or w/o BREAK to be last value instead of next.
        2. changed FOREACH behaviour with NL strings to always treat as lines. strings without NL will
            no longer be separated character-by-character. 
            lib-string and/or FOR with len(x)-1 should be used instead.
        3. SETGLOB: rewrote array ref handling. 
        4. added some type and range checking to substr(). 
        5. added string case to vgetElement().

      issues:
        1. problem with \n handling inside string interpolation...

            - workaround is to either:
                use backticks when embedding instead of double-quotes, or,
                ensure string is evaluated before use in print/iteration.

            - example similar to word_ls() in eg/alias:
                this works:

                    strls="a\nb\nc\n"; sep="\n"
                    foreach w in strls
                        word_out=word_out+w+sep
                    endfor

                however, if changed to ' word_out=word_out+"{w}{sep}" ', it fails to unquote the string literal.
                and, if changed to ' word_out=word_out+`{w}{sep}` ', then iterating over word_out after it is built will not work
                 as word_out would be a single string with embedded newlines.

            - this is all a bit messy and needs a better solution, but we can probably explain this behaviour well enough in the ref. doc.

            - this one is not going to be fixed yet. It is a consequence of the lexer and interpolation that may break other stuff if fixed.
                We could bodge it with escapes but this is not ideal. It should not alter existing behaviour if we fix this post version 1.


0.9

    * added fieldsort(s,f,type,dir) with types of "s","n","h".
        * it sorts a single-space-delimited set of columns in newline-separated rows on field f
        * "s" string, "n" numeric, "h" human readable numeric

    * added numcomp(str_a,str_b) library function.
    * added len() alias for length()

    * added mime-type handling to web_serve_* "s" rule. see eg/web for example. css/js should
        work somewhat better now.

    * added line_match()  ( returns bool from string )
    * added line_filter() ( returns matching lines from string )

    * added nl separated string support to uniq(). probably best to field_sort() the string first!

    * added home/end for start/end line in interactive mode keyboard handler.


0.8.6

    * removed some terminating newline mishandling from FOREACH and interpolate().

    * added back-end headers to "p" proxied requests in web_serve_*
    * added a proxied-by-za header also (temporarily) for troubleshooting.

    * added a stable log2(n) function.
    * add a function web_max_clients() to get the current MAX_CLIENT const cap.
    * added list_string() function for converting to a string list.
    * added a PRINTLN keyword.

    * fixed sort order of categories in funcs() call.
    * fixed issue with empty functionArgs slice in function definition holder 'dargs'.
    * fixed an issue with string concatenation using + symbol. removed + from identifier_set.

    * added -e cli arg for providing a program in a string (like sed/awk). For example:

        * host -t A www.google.com | 
            za -e 'foreach l in read_file("/dev/stdin"); fields(l); println F4; endfor'

        * a consequence of this is that stdin is ignored as a program source and can then be
            consumed as data instead.

        * another contrived example, to find all 2nd level depth directory names for a given path:

        sudo find /var/www | 
            za -e 'foreach _line in read_file("/dev/stdin")+"\n"
                        fields(_line,"/")
                        if NF>3
                            path="/"+F1+"/"+F2+"/"+F3+"/"+F4
                            on is_dir(path) do all=append(all,path)
                        endif
                      endfor
                      foreach l in uniq(list_string(all)); println l; endfor'

    * added -r cli arg for wrapping up a provided -e arg in a loop iterating /dev/stdin. 

        For example:

        * host -t A www.google.com | za -r -e 'println F4'
        -or-
        * za -r -e 'println field(_line,1,":")' </etc/group
        -or-
        * cat /usr/share/dict/british-english | 
            za -r -e 'if match(F1,"^[mM]"); println "-->",F1; endif'

        * this mirrors a little more the behaviour of awk. each line of stdin is 
            available as the "_line" variable. There is no facility for BEGIN or
            END sections, however, anything as complicated as that should probably
            just manage the loop itself in a bigger script.

          The line handling is just:

            # BEGIN {}
            # LOOP {
            NL=0
            foreach _line in read_file("/dev/stdin")
                inc NL
                fields(_line,"F_FLAG")
                # PROGRAM_SOURCE_FROM_E_FLAG
            endfor
            # }
            # END {}

        * each line is automatically put through the fields() function. 
        * NF is the number of fields on each line of input.
        * NL is the number of the current line of input.

        For example:
        * za -e 'on NF>9 do println NL," ",NF," ",F10' -r <test_file

    * added -F cli arg for setting the field separator of -r.

        For example:
        * za -F ":" -r -e 'println F1' </etc/group

    * added a locks() function for enabling/disabling the mutex locks at run-
        time (like the -l flag).

    * added function net_interfaces() to retrieve a newline separated list of
        available network interface names.

    * added missing arg count checks to all standard library functions.

    * confirmed that on..do return|continue|break|exit all work as expected.

    * added nil check in uniq()+sort() library functions. removed some dead code in uniq().


0.8.5

    * added -l flag for command line args. This controls if the bulk of in-built 
        mutex locks are applied or not.

        * For certain activities, such as web servers generating dynamic content,
            it is imperative that this flag is on.

        * For general use and for static web servers it is probably not needed currently.

        * Having mutex locks enabled will slow down execution considerably, 
            especially around variable handling.

    * web server "f" function rule complete... i think. it's working anyway :)

    * wrapped up the primary globals that would be affected by concurrent access when 
        using the "f" web serve rule.

    * almost everything global is now surrounded by or has been tested with a 
        sync.RWMutex or deadlock.Mutex wrapping.

    * all za variables have been wrapped in a uniform access mechanism including locking.
        It's reduced speed a bit more again, but had to be done for web concurrency.
 
    * added a rate limit cap to concurrent requests through the web servers. 
        (MAX_CLIENTS=800 in constants.go)

        * there is an internal limitation on this client count before you run into resource
            issues. You can tweak LOOP_MAX also to adjust this.

        * this needs language controls and some tidying before general use. The 800
            concurrent client limit is plenty for now though.

        * static page serving on a typical small VM of:

          * a small image (~36k) http://localhost:8080/headers/blue-flower.jpg:
            * weighttp -n 10000 -c100 -t4 -k http://localhost:8080/headers/blue-flower.jpg
            * finished in 0 sec, 563 millisec and 438 microsec, 17748 req/s, 643770 kbyte/s
            * requests: 10000 total, 10000 started, 10000 done, 10000 succeeded, 0 failed, 0 errored
            * status codes: 10000 2xx, 0 3xx, 0 4xx, 0 5xx
            * traffic: 371430000 bytes total, 1100000 bytes http, 370330000 bytes data

          * a small dynamic page (7.5k output) generated in Za http://localhost:8080/fun/awsip:
            * weighttp -n 10000 -c100 -t4 -k http://localhost:8080/fun/awsip
            * finished in 19 sec, 357 millisec and 461 microsec, 516 req/s, 3798 kbyte/s
            * requests: 10000 total, 10000 started, 10000 done, 10000 succeeded, 0 failed, 0 errored
            * status codes: 10000 2xx, 0 3xx, 0 4xx, 0 5xx
            * traffic: 75303683 bytes total, 1238705 bytes http, 74064978 bytes data

        * ... so, not exactly ballistic, but good enough for a filthy quick report generator.

    * fixed up missing Close() calls on http client requests.

    * added web page element builders for 'html,head,body,table,thead,th,tr,td,a,p,div,link'
        * updated eg/web to include an example function handler for "f" proxy rules 
            which uses the above builders.

    * added elements: h1,h2,h3,h4,h5,ol,ul,li

    * fixed 'globalaccess', getglob, globkey, setglob calls
        - they were busted by some of the changes in this release and 0.8.4

    * updated eg/web to demo text-to-html serving.

    * added @execpath global. (location of executed source file).
    * updated module command to use @execpath+module_path if module_path is relative.
    * added execpath() lib function.

    * updated ./build script to deal with changed params for Alpine static build.

    * moved HTML components into their own library (lib-html.go)

    * HTML element builders; enough done for now - will add more later, but current selection is adequate for non-interactive pages.

    * any other work required to get web servers adequately operating. did some tidying, multi-threading refactor and performance testing. 

    * updated za.vim again.
    * updated reference manual.

    * added layer on top of ajstarks/svgo interface. currently incomplete. will not implement all functions, just the basics.
        * added square, rect, roundrect, plot, line, circle, ellipse, group, text, description,
        * added image, def, polyline, polygon, grid, link.

    * added -s option to specify coprocess shell to use.
    * stopped some globals from being created when -s used. (i.e. not the default bash)
    * added @zsh_version global and zsh_version() function.

    * added { and } to alphaplus set for lexer to permit them as part of an identifier token.
    * now allowing indirection of the FOREACH and FOR iterator variable. This allows you, for example, to do:
        * y="x"; list=[1,2,3,4,5]; foreach {y} in list; on eval("x<3") do print list[key_{y}]; endfor
            * ... outputs 1 and 2
            * you could use {{y}} inside a string literal instead of list[key_{y}] outside.
            * see example in eg/proc_data

    * added a flag (-c) for disabling ANSI code output. (only from [#..] macros).
        * direct use of escaped ANSI codes still work.
        * this is just for removing undesirable non-printables when trying to process the output of a za program.

    * added log10(n) function. log(n,b) is imprecise with powers of 10. needed stable log10 for graphs, so
        added it to the library also.

    * cut/copy/paste working in interactive mode. it could do with some improvements still to non-printable character,
        utf handling and cursor positioning, but it is reasonably sound. 
        paste limit is set to strings of >6 characters. (upto 4096*3 byte chars)
        * linux keyboard codes can be anything up to 6 characters in length. e.g. shift-down: 0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x42
        * In order to eventually accept all of the relevant combinations we set the limit above this. We could fix this, but it 
            would mean rewriting the getch() function to act quite differently. Not currently a priority.

    * Added up/down cursor during multiline input.
        There's still some issues such as multiline input not clearing correctly from console when navigating history
            and other similar artifacts depending on operation selected. Nothing urgent though.

    * Added response headers to web_get(). web_get now returns a list of 2 items. res=web_get("https://example_site"); res[0]=body, res[1]=headers.
        * the headers can be iterated with foreach (e.g. foreach i in res[1]; print key_i,"->",i; endfor)
        * if read into another variable (e.g. z=res[1]) then the fields can be referenced directly (e.g. print z["Date"],z["Server"],z["Expires"])
            * the above indirection is because we don't support 2 dimensional arrays.
        * web_download() still functions as before, and downloads the file to a storage path, if possible, but does not consider headers.

    * Added web_custom() for performing a http request with custom headers.

    * Added base64e() and base64d() library functions.

    * Added example eg/rancher2_deployments.


0.8.4
    * reworked userDefEval.. it was pretty broken. Of course, everything is slower again now it's fixed :)
    * fixed missing solobind symbol ampersand (&). fixes bitwise ops problem (needing brackets).
    * added arg count check to userDefEval() (is greater than expected then error)
    * added web_post() library function - takes url and k-v map.
    * changed yyInitialStackSize up to 4 in the expression parser - shows as the best average to avoid stack allocs
    * added numcomma() for formatting numbers with optional precision.
    * added []interface{} type to min,max,sum,avg functions in lib-list. automatically casts to float64.
    * Line numbering of tokens was off by a few units. Resolved.
        * Was not adding to count for braced expressions () and {} which contained line feed characters.
    * Started new example: proc_data to demo larger list processing (1 million values): min,max,avg,sum,transform,reduce tests
    * updated za reference document
    * changed rand() behaviour to return int between 1..n inclusive instead of 0..n-1
        * you could not feed rand back into itself as underlying rand.Intn() would panic with an input of 0.
        * may also add a rand0() function later to replicate original behaviour
    * evaluator optimisations
        * we've done about as much as possible now without taking yacc apart too much more.
        * to speed up simple loop calcuations, use the "INC/DEC a x" commands instead of a=a+-x to help avoiding the evaluator.
            * this will use built-in eval for constant ints and za variables but still pass out to the evaluator for anything complicated.
            * this has quite an effect on loop speed. we now loop at similar speed to Python xrange for such simple cases.
               * we are not aiming for any better than this currently - it would need a completely different evaluator.
    * fixed accessField to use evaluated field index to get maps indices working as expected again.
    * removed spent MODULEs after they have been executed.
    * cleaned up SHOWDEF output.
    * fixed PANE DEFINE to use comma delimiters and evaluate arguments properly (including interpolation).

    * added web server support (basic!):
        * You won't be replacing nginx with this - it is intended for emergency situations where you need either a 
            reverse proxy or a static web server in a rush. The general use case might be generating a set of reports and 
            making them available quickly. i.e. sending people a hyperlink to their index. Alternatively, you may need to
            put error detection in front of another web server or between a dumb load balancer and a service.

        * new library calls in lib-net.go:
            * ident=web_serve_start(docroot[,tcp_port,interface_ip])
            * web_serve_stop(ident)
            * bool_avail=web_serve_up(ident)
            * web_serve_path(ident,path,mutation)

        * added example script at eg/web
        * added new logging commands:
            * LOGGING WEB 0/OFF/DISABLE | 1/ON/ENABLE
            * LOGGING ACCESSFILE file_name

    * added rate limiting to web logging. when message repeats exactly (except timestamp) only the first 5 are shown.
        * thereafter, every 10000 messages are skipped, until the message changes.

    * added web_serve_log_throttle() for the setting the lastWlogStart and lastWlogEvery variables

    * added simple support for POST and HEAD requests in reverse proxy rules. It's probably buggy at this stage.
        * form data is copied over from the original request

    * added support for query (?) and fragments (#) in reverse proxy GET and HEAD requests.
        * need to check if this is needed elsewhere.

    * added web_head() library function. checks success of a HTTP HEAD call.

    * updated za.vim syntax file

    * added checks for variable existence before first use on r.h.s. 

    * fixed CONTINUE in ON..DO (similar to previous BREAK issue).


0.8.3
    * *sigh* pulled apart goval package, turned mapped variables into array-based.
        * there is now a separate variable stack per function space.
    * added a few helper functions for handling Variable structs.
        * this has all further reduced GC and run-time complexity.
    * in doing this, a few problems fell out with indices and reflection of struct literals.
        * ended up changing most of lib-list to accommodate this.
        * lib-list now only supports lists of string, float64, int and bool (where appropriate).
        * lib-list silently supports interface{} where convenient.
    * now propagating evalfs through goval from Evaluate() call. Allows for nesting/recursion calling back and forth between udf and goval.
    * warn if lib call/var has same name as fn/keyword instead of silently dropping.
        * added -A startup flag to set global safetyAssign
        * safetyAssign checked on first declaration of new variable names per function
            * when true, checks stdlib and keywords against new var name.
        * -A defaults to off as it incurs a small speed penalty. (this might change)
    * possibly fixed now... za functions cannot be processed when contained inside a standard library call. (should be interchangeable now)
    * list_int() was discarding rather than rounding down floats. 
        * GetAsInt() now converts strings to float then int. errors if still no conversion possible.
    * added a bypass in FOR loops so that the counter variable is only set at the end of the loop when it has not been referenced during the loop.
        * Much faster iterations when value is not needed. Saves a write inside the loop.
    * added Close() of input stream when bash coproc is unexpectedly interrupted, before new coprocess launched.
        * not perfect still, but less remnant input breaking interactive mode.
    * changed FOREACH to handle literal lists (int,float,string,mixed)
    * changed FOREACH to convert single int or float64 results into a list for iteration.
    * more type/existence checking around accessField (which we currently do not use, but for which syntax is still handled).
    * Hacked up int_lexer and int_parser some more:
        * Removed temp vars and length checks where appropriate. (Replaced with alternatives).
        * Removed dead initialisations.
        * Tweaked GC limit again (back downwards).
        * changed yyInitialStackSize down to 2 in the parser.
        * Unrolled some -/+2 calculations into double post increments to hopefully inform the compiler better. (And remove in-between +1/-1 calcs).
        * Removed a dead yyTok3 section (contained only int{0} in the data).
        * Added a 4 variable lookup cache to vget()
    * added some support for uint8
    * converted all CartonToken to Token types. Removed the carton type.
    * added a tokVal field to Token which carries evaluation results.
    * references to .name field changed to .tokText field.


0.8.2
    * made funcs() arg optional.
    * started adding unit/coverage tests
    * moved enact() functionality into Call(). changed calling params to include a mode flag
        * modes: MODE_CALL, MODE_ENACT. 
        * resulted in approx. 10% speed up processing commands and much less GC.
    * added return value of breakIn from Call() back in. This sets breakIn in the caller after an ON..DO command.

0.8.0
    tested: "pipesep() broken"
      * mostly okay. added code to reset fields to null before scan. reduced NF size by 1.
    tested: "we should be able to directly assign entire arrays, eg. prev=getglob("prev") but this is currently not supported!"
      * seems to work fine, at least in interactive mode.
    Added guard against some variable misnaming (when same as keywords)
    Added some more error checking.
    Removed some unneeded assignment from the evalCrush* functions.
    Tweaked GOGC to be lazier.
    Added a -P flag for capturing trace output.
    Made -f arg optional. Will take filename to execute from first unprocessed cmd line arg instead if present.
    Fixed FOREACH looping over empty expression string results
    Changed funcs() to only match function names, not categories.
    Changed some more finish() conditions to not break out of interactive mode on error.
    Other library changes:
        * type check added for arg #3 in col()
        * added a few more types (int,int32,int64,float32) to head()
        * added a few more types (int,int32,int64,float32) to tail()
        * fixed panic in sort() when all element types didn't match.
        * fixed panic in uniq() when all element types didn't match.
        * added new similar() function in lib-list.
        * added optional new file mode in write_file()
        * added optional field separator for db_query() (arg#3:string,default:"|")
        * changed tokens() to return a token list instead of trying to print one.
        * fixed up pad() some more. (odd division size rounding)
    Updated eval() output to show returned error strings when needed.
    Updated za.vim background (hi Normal bg NONE rather than Black)
    Updated vim syntax file for changed commands.

0.7.9
    added eval() stdlib function for expression evaluation of provided string.
    added library function and keyword lookup as argument to HELP command.
    updated vim syntax file
    changed debug to use a global level int instead of a za mapped variable. should improve call rejection speed a little.

0.7.8
    changed the bulk of the map[uint64] internal trackers to slice-of types.
    bypassed some function calls where possible inside ev().
    updated vim syntax file.

0.7.7
    updated coprocess calls to return results char-by-char instead of using ReadBytes(delim). turns out, it is much faster!
    added a handler to recreate the coprocess on a user interrupt...
      previously the coprocess would potentially hang in the background after an interrupt in interactive mode.
    moved opening brace check to the inside of the interpolate() function. interpolate gets called from other places now than just ev()
      so, extra fn call in ev() but speeds up evaluation in general because of early interpolate terminations elsewhere.
    disabled debug statements in source. they currently perform too slowly to leave in place. 

0.7.6
    updated service() and install() to fix version/package manager mismatches.
    small bodge for ON..DO | cmd syntax to temporarily duct tape it. Needs an overhaul.
    updated reference manual

0.7.5
    modified C_Return logic and debugging.
    fixed a bug in init system detection for lib-package
    added a -T option for setting the max_timeout value in calls to bash coproc.
    added LOGGING QUIET|LOUD settings to squash console output for LOG messages.
    added some fixes to line_replace() and line_add() for newline characters.
    added LOGGING SUBJECT expression for amending the prepended log line string.

0.7.4
    added local() function for dereferencing a local value.
    removed error states from is_dir() lib function.

0.7.3
    started testing under Windows/WSL/Ubuntu-18.04
    added fix for on ... do break

0.7.2
    fixed exit code evaluation in EXIT command.
    added usage information for INPUT and PROMPT.
    fixed exceptions in INPUT and PROMPT.
    now cleaning out @temp in caller pre function call. 

0.7.1
    added note in docs about avoiding interpolation in normal assignments
    showdef output: fixed missing EOL chars.
    fixed right-hand side interpolation for some assignment cases. e.g. {a_{c}}
    added some support on LHS of assignments for interpolation.
        * still needs adding in many cases, e.g. ZERO, INC, DEC, SETGLOB, probably bash command assignment
        * need to confirm this already works in array element name building -- DONE/not working/BP1
    added ON command : ON condition DO command

0.7.0
    fixed return value string quoting

0.6.9
    fixed col()
    fixed is_number()
    added syntax highlighting for library functions and user-defined functions (vim syntax file in doc/za.vim)

<0.6.9 historic: probably have the fix details somewhere, but these versions were internal only.


